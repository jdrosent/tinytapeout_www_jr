[
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "simon.v"
            ],
            "top_module": "fraserbc_simon",
            "git_url": "https://github.com/Fraserbc/tt02-simon"
        },
        "documentation": {
            "author": "Fraser Price",
            "discord": "frsr#5381",
            "title": "SIMON Cipher",
            "description": "Simon32/64 Encryption",
            "how_it_works": "Encrypts data by sending it through a feistel network for 32 rounds where it is combined with the round subkey and the last round. Data is entered into the core via shift registers.\n",
            "how_to_test": "Set shift high and shift data in lsb first, 4 bits at a time. Shift in 96 bits, 32 being data and 64 being the key, with the plaintext being shifted in first. Eg if the plaintext was 32'h65656877 and key was 64'h1918111009080100, then 96'h191811100908010065656877 would be shifted in. Once bits have been shifted in, bring shift low, wait 32 clock cycles then set it high again. The ciphertext will be shifted out lsb first.\n",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "shift",
                "data_in[0]",
                "data_in[1]",
                "data_in[2]",
                "data_in[3]",
                "none",
                "none"
            ],
            "outputs": [
                "data_out[0]",
                "data_out[1]",
                "data_out[2]",
                "data_out[3]",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "tomkeddie_top_tto.v",
                "lcd.v"
            ],
            "top_module": "tomkeddie_top_tto",
            "git_url": "https://github.com/TomKeddie/tinytapeout-2022-2"
        },
        "documentation": {
            "author": "Tom Keddie",
            "discord": "TomKeddie#7070",
            "title": "HD74480 Clock",
            "description": "Displays a clock on a attached HD74480",
            "how_it_works": "See https://github.com/TomKeddie/tinytapeout-2022-2/blob/main/doc/README.md",
            "how_to_test": "See https://github.com/TomKeddie/tinytapeout-2022-2/blob/main/doc/README.md",
            "external_hw": "HD74480",
            "language": "verilog",
            "doc_link": "https://github.com/TomKeddie/tinytapeout-2022-2/blob/main/doc/README.md",
            "clock_hz": 1000,
            "picture": "doc/wiring.png",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "hour set",
                "minute set"
            ],
            "outputs": [
                "lcd D4",
                "lcd D5",
                "lcd D6",
                "lcd D7",
                "lcd EN",
                "lcd RS",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "matrix.v"
            ],
            "top_module": "chrisruk_matrix",
            "git_url": "https://github.com/chrisruk/matrixchip"
        },
        "documentation": {
            "author": "Chris",
            "discord": "hoglet",
            "title": "Scrolling Binary Matrix display",
            "description": "Display scrolling binary data from input pin on 8x8 SK9822 LED matrix display",
            "how_it_works": "Uses 8x8 matrix SK9822 LED display to scroll binary data as 0s and 1s in a simple font, from the input pin.  Designed in verilog and tested using iCEstick FPGA Evaluation Kit.  Each LED takes a 32 bit value, consisting of r,g,b and brightness.",
            "how_to_test": "Need 8x8 matrix SK9822 LED display and level shifter to convert output clock and data logic to 5V logic.",
            "external_hw": "Requires 8x8 matrix SK9822 LED display and 3.3V to 5V logic level shifter to convert the data and clock signals to the correct voltage for the display.",
            "language": "verilog",
            "doc_link": "https://github.com/chrisruk/matrixchip/blob/main/README.md",
            "clock_hz": 6000,
            "picture": "images/animation.gif",
            "inputs": [
                "clock",
                "reset",
                "digit",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "LED Clock",
                "LED Data",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "sequencer.v"
            ],
            "top_module": "loxodes_sequencer",
            "git_url": "https://github.com/loxodes/tt02-submission-loxodes"
        },
        "documentation": {
            "author": "Jon Klein",
            "discord": "loxodes",
            "title": "Power supply sequencer",
            "description": "Sequentially enable and disable channels with configurable delay",
            "how_it_works": "Counters and registers control and track the state of channel activations. The delay input sets the counter threshold.",
            "how_to_test": "After reset, bring enable high to enable channels sequentially, starting with channel 0. Bring enable low to switch off channels sequentially, starting with channel 7.",
            "external_hw": "None, but could be useful for GaAs amplifiers or other circuits which need sequenced power supplies.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 12500,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "enable",
                "delay0",
                "delay1",
                "delay2",
                "delay3",
                "delay4"
            ],
            "outputs": [
                "channel 0",
                "channel 1",
                "channel 2",
                "channel 3",
                "channel 4",
                "channel 5",
                "channel 6",
                "channel 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "top.v",
                "pwm.v",
                "debouncer.v",
                "synchronizer.v"
            ],
            "top_module": "migcorre_pwm",
            "git_url": "https://github.com/migcorre/tt02-dc"
        },
        "documentation": {
            "author": "Marcelo Pouso / Miguel Correia",
            "discord": "not",
            "title": "Duty Controller",
            "description": "Increase/Decrease a duty cycle of square signal.",
            "how_it_works": "Enter a square clock of 12.5Khz, and change its duty cycle by pressing increase or decrease bottom. The change will be in steps of 10%. The increase and decrease inputs have an internal debouncer that could be disabled with the input disable_debouncer = 1.",
            "how_to_test": "Connect a signal clock (io_in[0]), reset active high signal (io_in[1]), a button to control the incremental input (io_in[2]) and another button to control the decremental input(io_in[3]), and finally forced to 0 the disable_debouncer input (io_in[4]). The output signal will be in the pwm (io_out[0]) port and the negate output in pwm_neg (io_out[1]). The signal output will have a frecuency of clk/10 = 1.2Khz. When you press the incremental input bottom then the signal will increment by 10% Its duty cycle and when you press the decremental input bottom you will see that the output signal decrement by 10%.",
            "external_hw": "A 12.5Khz clock signal generator and 2 bottoms for incremental and decremental inputs. An oscilloscope to see the output PWM 1.2KHZ signal. ",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 12500,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "increase",
                "decrease",
                "disable_debouncer",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "pwm",
                "pwm_neg",
                "increase",
                "decrease",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "s4ga.v"
            ],
            "top_module": "s4ga",
            "git_url": "https://github.com/grayresearch/tt02-s4ga"
        },
        "documentation": {
            "author": "Jan Gray",
            "discord": "jangray",
            "title": "S4GA: Super Slow Serial SRAM FPGA",
            "description": "one fracturable 5-LUT that receives FPGA LUT configuration frames, serially evaluates LUT inputs and LUT outputs",
            "how_it_works": "The design is a single physical LUT into which an external agent pours a series of 92b LUT configuration frames, four bits per cycle. Every 23 clock cycles it evaluates a 5-input LUT. The last N=283 LUT output values are kept on die to be used as LUT inputs of subsequent LUTs. The design also has 2 FPGA input pins and 7 FPGA output pins.",
            "how_to_test": "tricky",
            "external_hw": "serial SRAM or FLASH",
            "language": "verilog",
            "doc_link": "https://github.com/grayresearch/tt02-s4ga/blob/main/README.md",
            "clock_hz": "",
            "picture": "doc/S4GA-block-diagram.png",
            "inputs": [
                "clk",
                "rst",
                "si[0]",
                "si[1]",
                "si[2]",
                "si[3]",
                "in[0]",
                "in[1]"
            ],
            "outputs": [
                "out[0]",
                "out[1]",
                "out[2]",
                "out[3]",
                "out[4]",
                "out[5]",
                "out[6]",
                "debug"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "alu.v",
                "alu_top.v"
            ],
            "top_module": "alu_top",
            "git_url": "https://github.com/ryancor/tt02-submission-template"
        },
        "documentation": {
            "author": "Ryan Cornateanu",
            "discord": "hackeranium#2982",
            "title": "ALU",
            "description": "2bit ALU with a ripple carry adder that has the capability to perform 16 different calculations",
            "how_it_works": "When 4 bits total are input'd into the ALU, it goes through 3 ripple carries and two finite state machines that adds to a temporary value that gets included in the basic ALU calculations",
            "how_to_test": "TODO",
            "external_hw": "",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "A1",
                "A2",
                "B1",
                "B2",
                "ALU_Sel1",
                "ALU_Sel2",
                "ALU_Sel3",
                "ALU_Sel4"
            ],
            "outputs": [
                "ALU_Out1",
                "ALU_Out2",
                "ALU_Out3",
                "ALU_Out4",
                "ALU_Out5",
                "ALU_Out6",
                "ALU_Out7",
                "CarryOut"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "mccoy.v",
                "add1.v",
                "alu.v",
                "branch.v",
                "decoder.v",
                "iSign.v",
                "mux2.v",
                "mux3.v",
                "mux4.v",
                "notx8.v",
                "pc.v",
                "register.v",
                "x8.v"
            ],
            "top_module": "aidan_McCoy",
            "git_url": "https://github.com/AidanGood/tt02-McCoy"
        },
        "documentation": {
            "author": "Aidan Good",
            "discord": "Aidan G",
            "title": "The McCoy 8-bit Microprocessor",
            "description": "Custom RISC-V inspired microprocessor capable of simple arithmatic, branching, and jumps through a custom ISA.",
            "how_it_works": "This chip contains an opcode decoder, 8-bit ALU, 7 general purpose and 3 special purpose 6-bit registers, branch target selector, and other supporting structures all connected together to make a 1-stage microprocessor",
            "how_to_test": "To put the processor in a valid state, hold the reset pin high for one clock cycle. Instructions can begin to be fed into the processor at the beginning of the next cycle when reset is set low. When the clock signal is high, the PC will be output. When the clock signal is low, the x8 register will be output. There are example programs in the testbench folder and a more thourough explaination in the project readme.",
            "external_hw": "Any source that allows for 16 GPIO pins. 8 to set the input pins, 8 to read the output pins.",
            "language": "Whole thing is written and tested in verilog.",
            "doc_link": "https://github.com/cpldcpu/tinytapeout_mcpu5/blob/main/README.md",
            "clock_hz": null,
            "picture": "https://github.com/cpldcpu/tinytapeout_mcpu5/blob/main/McCoy_Diagram.png",
            "inputs": [
                "clk",
                "reset",
                "in0",
                "in1",
                "in2",
                "in3",
                "in4",
                "in5"
            ],
            "outputs": [
                "out0",
                "out1",
                "out2",
                "out3",
                "out4",
                "out5",
                "out6",
                "out7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "binary_clock.v"
            ],
            "top_module": "azdle_binary_clock",
            "git_url": "https://github.com/azdle/binary-clock-asic"
        },
        "documentation": {
            "author": "Azdle",
            "discord": "azdle",
            "title": "binary clock",
            "description": "A binary clock using multiplexed LEDs",
            "how_it_works": "Hours, minutes, and seconds are counted in registers with an overflow comparison. An overflow in one, triggers a rising edge on the input of the successive register.\nThe values of each register are connected to the input to a multiplexer, which is able to control 12 LEDs using just 7 of the outputs.\nThis design also allows use of the PPS input for more accurate time keeping. This input takes a 1 Hz clock with a rising edge on the start of each second.\nThe hours[4:0] inputs allow setting of the hours value displayed on the clock when coming out of reset. This can be used for manually setting the time, so it can be done on the hour of any hour. It can also be used by an automatic time keeping controller to ensure the time is perfectly synced daily, for instance at 03:00 to be compatible with DST.\n",
            "how_to_test": "After reset, the output shows the current Hours:Minutes that have elapsed since coming out of reset, along wit the 1s bit of seconds, multiplexed across the rows of the LED array.\nThe matrix is scanned for values:\n    rows[2:0] = 4'b110; cols[3:0] = 4'bMMMS;\n    rows[2:0] = 4'b101; cols[3:0] = 4'bHHMM;\n    rows[2:0] = 4'b011; cols[3:0] = 4'bHHHH;\n\n(M: Minutes, H: Hours, x: Unused)\nDirectly out of reset, at 0:00, a scan would be:\n    rows[2:0] = 4'b110; cols[3:0] = 4'b0000;\n    rows[2:0] = 4'b101; cols[3:0] = 4'b0000;\n    rows[2:0] = 4'b011; cols[3:0] = 4'b0000;\n\nAfter one second, at 00:00:01, a scan would be:\n    rows[2:0] = 4'b110; cols[3:0] = 4'b0001;\n    rows[2:0] = 4'b101; cols[3:0] = 4'b0000;\n    rows[2:0] = 4'b011; cols[3:0] = 4'b0000;\n\nAfter one hour and two minutes, at 1:02, a scan would be:\n    rows[2:0] = 4'b110; cols[3:0] = 4'b0110;\n    rows[2:0] = 4'b101; cols[3:0] = 4'b0100;\n    rows[2:0] = 4'b011; cols[3:0] = 4'b0000;\n\nThe above can be sped up using the PPS (Pulse Per Second) input, as long as the PPS pulses are kept to 1 pulse per 2 clock cycles or slower.\nThe hours input can be tested by applying the binary value of the desired hour. Asserting reset for at least one clock cycle, and checking the value of hours displayed in the matrix.\n",
            "external_hw": "This design expects a matrix of 12 LEDs wired to the outputs. The LEDs should be wired so that current can flow from column to row.\nOptionally, a real time clock or GPS device with PPS output may be connected to the `pps` pin for more accurate time keeping. If unused this pin must be pulled to ground.\n",
            "language": "verilog",
            "doc_link": "https://github.com/azdle/binary-clock-asic",
            "clock_hz": 200,
            "picture": "https://azdle.github.io/binary-clock-asic/gds_render.svg",
            "inputs": [
                "clock",
                "reset",
                "pps",
                "hours_b1",
                "hours_b2",
                "hours_b4",
                "hours_b8",
                "hours_b16"
            ],
            "outputs": [
                "col 0",
                "col 1",
                "col 2",
                "col 3",
                "row 0",
                "row 2",
                "row 3",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347787021138264660",
            "git_url": "https://github.com/justinP-wrk/tt02-TinySensor"
        },
        "documentation": {
            "author": "Justin Pelan",
            "discord": "Tavangel",
            "title": "TinySensor",
            "description": "Using external hardware photodiodes as inputs, display light intensity on the 7-segment display",
            "how_it_works": "Inputs 1-6 will be connected to external photodiodes to read either a '0' or '1', inputs will be added together and displayed on the 7-segment display",
            "how_to_test": "Dip switches 1-6 can be used instead of external hw to provide inputs, and 7 is used to switch between Step or Continous sample mode. Throw the switches and the total number should show up on the 7-segment display",
            "external_hw": "Breadboard, resistors, photodiodes, specific part# TBD",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "TT01.png",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "sram_top.v"
            ],
            "top_module": "jar_sram_top",
            "git_url": "https://github.com/jar/tt02_sram"
        },
        "documentation": {
            "author": "James Ross",
            "discord": "jar#1709",
            "title": "16x8 SRAM & Streaming Signal Generator",
            "description": "Write to, Read from, and Stream 16 addressable 8-bit words of memory",
            "how_it_works": "*WRITE MODE*: Write Enable (WE) pin high while passing 4-bits low data, 4-bits high data into an 8-bit temporary shift register. After loading data into the temporary shift register, setting Commit high while passing a 4-bit address will place the register value into memory.  Fast memset, such as zeroing memory, can be performed with Commit high while passing a new address per clock cycle.  *READ MODE*: While Output Enable (OE) high, a 4-bit address will place the data from memory into the temporary register returns 8-bit register to output data interface.  *STREAM MODE*: While WE, OE, and Commit high, pass the starting stream index address.  Then, while WE and OE are both high, the output cycles through all values in memory.  This may be used as a streaming signal generator.",
            "how_to_test": "After reset, you can write values into memory and read back. See the verilator testbench.",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "https://github.com/jar/tt02_sram/blob/main/README.md",
            "clock_hz": 0,
            "picture": "16x8sram.png",
            "inputs": [
                "clk",
                "we",
                "oe",
                "commit",
                "addr[0]/high[0]/low[0]",
                "addr[1]/high[1]/low[1]",
                "addr[2]/high[2]/low[2]",
                "addr[3]/high[3]/low[3]"
            ],
            "outputs": [
                "data[0]",
                "data[1]",
                "data[2]",
                "data[3]",
                "data[4]",
                "data[5]",
                "data[6]",
                "data[7]"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347690870424732244",
            "git_url": "https://github.com/JensIMS/tt02-trafficlight"
        },
        "documentation": {
            "author": "Jens Schleusner",
            "discord": "Jens S",
            "title": "German Traffic Light State Machine",
            "description": "A state machine to control german traffic lights at an intersection.",
            "how_it_works": "A state machine generates signals for vehicle and pedestrian traffic lights at an intersection of a main street and a side street. A blinking yellow light for the side street is generated in the reset state.",
            "how_to_test": "Provide a clock, hook up LEDs and generate a reset signal to reset the intersection to all-red. If your leave the reset signal enabled, a blinking yellow light is shown for the side street.",
            "external_hw": "An additional inverter is required to generate the pedestrian red signals from the green output. Hookup your own LEDs for the signals.",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 1,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "main street red",
                "main street yellow",
                "main street green",
                "main street pedestrian green",
                "side street red",
                "side street yellow",
                "side street green",
                "side street pedestrian green"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347592305412145748",
            "git_url": "https://github.com/svd321/tt02-Ising"
        },
        "documentation": {
            "author": "Seppe Van Dyck",
            "title": "4-spin Ising Chain Simulation",
            "description": "A self-contained physics simulation. This circuit simulates 4 spins of an Ising chain in  an external field.",
            "how_it_works": "It runs the Metropolis-Hastings monte-carlo algorithm to simulate 4 Ising spins in a linear chain with two external neighbours and an external field. Every monte-carlo step (10 clock cycles) a random number is created through a 32-bit LFSR and is compared to an 8-bit representations of the acceptance probability of a random spin flip. Using the inputs for external neighbors, N of these circuits can be chained together to create a 4N spin Ising chain.",
            "how_to_test": "The design can be tested by enabling one of the neighbours (input 4 or 5) and leave all other inputs low, the system will evolve into a ground state with every other spin pointing up.",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "README.md",
            "clock_hz": 20,
            "picture": "Overview_2.png",
            "inputs": [
                "clock, clock input.",
                "T0, LSB of the 3-bit temperature representation.",
                "T1, Middle bit of the 3-bit temperature.",
                "T2, MSB of the 3-bit temperature.",
                "N1, Value of neighbour 1 (up/1 or down/0).",
                "N2, Value of neighbour 2 (up/1 or down/0).",
                "J, The sign of the NN coupling constant J.",
                "H, Value of the coupling to the external field H."
            ],
            "outputs": [
                "segment a, Spin 0.",
                "segment b, Spin 1.",
                "segment c, Spin 2.",
                "segment d, Spin 3.",
                "segment e, Neighbour 2.",
                "segment f, Neighbour 1.",
                "none",
                "segment h, MC Step Indicator."
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "toplevel/logisimTopLevelShell.v",
                "arith/Adder.v",
                "arith/FullAdder.v",
                "arith/Comparator.v",
                "circuit/CPU.v",
                "circuit/clock_gen_2.v",
                "circuit/dest_reg_sel_new.v",
                "circuit/eq_0.v",
                "circuit/inst_dec.v",
                "circuit/int_memory.v",
                "circuit/main.v",
                "circuit/output_logic.v",
                "circuit/mul2.v",
                "circuit/div.v",
                "gates/AND_GATE.v",
                "gates/AND_GATE_BUS.v",
                "gates/NAND_GATE.v",
                "gates/NAND_GATE_BUS.v",
                "gates/NOR_GATE.v",
                "gates/OR_GATE.v",
                "gates/OR_GATE_BUS_4_INPUTS.v",
                "gates/XOR_GATE_ONEHOT.v",
                "memory/D_FLIPFLOP.v",
                "memory/REGISTER_FLIP_FLOP.v",
                "plexers/Demultiplexer_16.v"
            ],
            "top_module": "tholin_avalonsemi_5401",
            "git_url": "https://github.com/89Mods/tt2-AvalonSemi-5401"
        },
        "documentation": {
            "discord": "Tholin#7559",
            "author": "Tholin",
            "title": "Avalon Semiconductors '5401' 4-bit Microprocessor",
            "description": "4-bit CPU capable of addressing 4096 bytes program memory and 254 words data memory, with 6 words of on-chip RAM and two general-purpose input ports. Hopefully capable of more complex computation than previous CPU submissions.",
            "how_it_works": "The chip contains a 4-bit ALU, a 4-bit Accumulator, 8-bit Memory Address Register and 12-bit \u02ddDestination Register\u02dd, which is used to buffer branch target addresses. It also has two general-purpose input ports. The instruction set consists of 16 instructions, containing arihmatic, logical, load/store, branch and conditional branch instruction. See the full documentation for a complete architectural description.",
            "how_to_test": "It is possible to test the CPU using a debounced push button as the clock, and using the DIP switches on the PCB to key in instructions manually. Set the switches to 0100_0000 to assert RST, and pulse the clock a few times. Then, change the switches to 0000_1000 (SEI instruction) and pulse the clock four times. After that, set the switches to all 0s (LD instruction). Pulse the clock once, then change the switches to 0001_0100, and pulse the clock three more times. Lastly, set the switches to 0011_1100 (LMH instruction). If done correctly, after two pulses of the clock, the outputs will read 0101_0000 and two more pulses after that, they will be xxxx_1000 (\u2019x\u2019 means don\u2019t care). This sequence should repeat for as long as you keep pulsing the clock, without changing the inputs.",
            "external_hw": "At the very minimum a program memory, and the required glue logic. See \u02ddExample system diagram\u02dd in the full documentation.",
            "language": "verilog",
            "doc_link": "https://github.com/89Mods/tt2-AvalonSemi-5401/blob/main/README.md",
            "clock_hz": 6000,
            "picture": "assets/block_diag.png",
            "inputs": [
                "CLK",
                "RST",
                "I0 / D0",
                "I1 / D1",
                "I2 / D2",
                "I3 / D3",
                "EF0",
                "EF1"
            ],
            "outputs": [
                "MAR0 / DR0 / DR8 / RR0",
                "MAR1 / DR1 / DR9 / RR1",
                "MAR2 / DR2 / DR10 / RR2",
                "MAR3 / DR3 / DR11 / RR3",
                "MAR4 / DR4 / F_MAR",
                "MAR5 / DR5 / F_WRITE",
                "MAR6 / DR6 / F_JMP",
                "MAR7 / DR7 / F_I"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "tiny_fft.v"
            ],
            "top_module": "tiny_fft",
            "git_url": "https://github.com/RiceShelley/tiny-fft"
        },
        "documentation": {
            "author": "Rice Shelley",
            "discord": "ganesh",
            "title": "small FFT",
            "description": "Computes a small fft",
            "how_it_works": "Takes 4 4-bit signed inputs (real integer numbers) and outputs 4 6-bit complex numbers",
            "how_to_test": "after reset, use the write enable signal to write 4 inputs. Read the output for the computer FFT.",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "wrEn",
                "none",
                "data_in_0",
                "data_in_1",
                "data_in_2",
                "data_in_3"
            ],
            "outputs": [
                "rd_idx_zero",
                "none",
                "data_out_0",
                "data_out_1",
                "data_out_2",
                "data_out_3",
                "data_out_4",
                "data_out_5"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "346553315158393428",
            "git_url": "https://github.com/moyesw/tt02-moyesw-StreamIntegrator"
        },
        "documentation": {
            "author": "William Moyes",
            "title": "Stream Integrator",
            "description": "A silicon implementation of a simple optical computation",
            "how_it_works": "It is possible to generate a pseudorandom bit sequence optomechanically using four loops of punched paper tape. Each of the four tape loops, labeled A, B, C, and D, encodes one bit of information per linear position using a tape specific hole pattern. The patterns are TapeA_0=XOOO, TapeA_1=OXOO, TapeB_0=OOXO, TapeB_1=OOOX, TapeC_0=OOXX, TapeC_1=XXOO, TapeD_0=OXOX, TapeD_1=XOXO, where O is a hole, and X is filled. The pseudorandom sequence is obtained by physically stacking the four tapes together at a single linear point, and observing if light can pass through any of the four hole positions. If all four hole positions are blocked, a 0 is generated. If any of the four holes allows light to pass, a 1 is generated. The next bit is obtained by advancing all four tapes by one linear position and repeating the observation. By using the specified bit encoding patterns, the expression (C ? A : B) ^ D is calculated. If all four tapes are punched with randomly chosen 1 and 0 patterns, and each tape's length is relatively prime to the other tape lengths, then a maximum generator period is obtained. This TinyTapeout-02 minimal project was inspired by the paper tape pseudorandom bit sequence generator. It implements the core (C ? A : B) ^ D operation electrically instead of optomechanically. An extra ^ E term is added for ease of use.",
            "how_to_test": "Run through the 32 possible input patterns, and verify the expected output value is observed. Counting from 00000 to 111111, where IN0 is the LSB (i.e. Tape A), and IN4 (i.e. Extra E) is the MSB should yield the pattern: 01010011101011001010110001010011.",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "Value from Tape A",
                "Value from Tape B",
                "Value from Tape C",
                "Value from Tape D",
                "Extra term XORed with generator output",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "Output",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347894637149553236",
            "git_url": "https://github.com/Tschucker/tt02-submission-tiny-fir"
        },
        "documentation": {
            "author": "Tom Schucker",
            "discord": "tdsepsilon",
            "title": "tiny-fir",
            "description": "4bit 2-stage FIR filter",
            "how_it_works": "Multiplies the input by the tap coefficient for each stage and outputs the sum of all stages",
            "how_to_test": "Load tap coefficients by setting the value and pulsing 2 times, then repeat for second tap. Change input value each clock to run filter. Select signals change output to debug 00(normal) 01(output of mult 2) 10(tap values in mem) 11(output of mult 1). FIR output discards least significant bit due to output limitations",
            "external_hw": "Arduino or FPGA",
            "language": "wokwi",
            "doc_link": "FIR_README.md",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "data0/tap0",
                "data1/tap1",
                "data2/tap2",
                "data3/tap3",
                "select0",
                "select1",
                "loadpulse"
            ],
            "outputs": [
                "fir1/mult0/tap10",
                "fir2/mult1/tap11",
                "fir3/mult2/tap12",
                "fir4/mult3/tap13",
                "fir5/mult4/tap20",
                "fir6/mult5/tap21",
                "fir7/mult6/tap22",
                "fir8/mult7/tap23"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "346916357828248146",
            "git_url": "https://github.com/steieio/tt02-submission-universal-sr"
        },
        "documentation": {
            "author": "Greg Steiert",
            "discord": "gsteiert #6753",
            "title": "Configurable SR",
            "description": "Configurable gates driving SR and D flip-flops",
            "how_it_works": "Two configurable gates enable a variety of complex flip-flop functions",
            "how_to_test": "When SEL and INV are low, the 0 inputs directly drive the flip-flops.  A-0 can be connected to the clock for use with the D flip-flop.",
            "external_hw": "none",
            "language": "wokwi",
            "doc_link": "https://github.com/steieio/tt02-submission-universal-sr/blob/main/README.md",
            "clock_hz": 0,
            "picture": "configurable-sr.png",
            "inputs": [
                "A-0",
                "A-1",
                "A-SEL",
                "A-INV",
                "B-0",
                "B-1",
                "B-SEL",
                "B-INV"
            ],
            "outputs": [
                "MUX-A",
                "XOR-A",
                "SR-Q",
                "D-Q",
                "MUX-B",
                "XOR-B",
                "SR-Q#",
                "D-Q#"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347594509754827347",
            "git_url": "https://github.com/leardilap/tt02-LUTRAM"
        },
        "documentation": {
            "author": "Luis Ardila",
            "discord": "leardilap",
            "title": "LUTRAM",
            "description": "LUTRAM with 4 bit address and 8 bit output preloaded with a binary to 7 segments decoder, sadly it was too big for 0-F, so now it is 0-9?",
            "how_it_works": "uses the address bits to pull from memory the value to be displayed on the 7 segments, content of the memory can be updated via a clock and data pins, reset button will revert to default info, you would need to issue one clock cycle to load the default info",
            "how_to_test": "clk, data, rst, nc, address [4:0]",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "https://github.com/leardilap/tt02-LUTRAM",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "data",
                "reset",
                "nc",
                "address bit 3",
                "address bit 2",
                "address bit 1",
                "address bit 0"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment pd"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "chase_the_beat.v",
                "top.v"
            ],
            "top_module": "chase_the_beat",
            "git_url": "https://github.com/ekliptik/tt02-chase-the-beat"
        },
        "documentation": {
            "author": "Emil J Tywoniak",
            "discord": "@widlarizer#0001",
            "title": "chase the beat",
            "description": "Tap twice to the beat, the outputs will chase the beat. Or generate some audio noise!",
            "how_it_works": "The second button press sets a ceiling value for the 1kHz counter. When the counter hits that value, it barrel-shifts the outputs by one bit. When the mode pin isn't asserted, the first output pin emits digital noise generated by a LFSR",
            "how_to_test": "Set 1kHz clock on first input. After reset, set mode to 1, tap the tap button twice within one second. The outputs should set to the beat",
            "external_hw": "A button on the tap input, a switch on the mode input, LEDs on the 8 outputs, and audio output on the first output. Don't just connect headphones or speakers directly! It could fry the circuit, you need some sort of amplifier.",
            "language": "amaranth",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clk",
                "rst",
                "tap",
                "mode",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "o_0 - LED or noise output",
                "o_1 - LED",
                "o_2 - LED",
                "o_3 - LED",
                "o_4 - LED",
                "o_5 - LED",
                "o_6 - LED",
                "o_7 - LED"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347688030570545747",
            "git_url": "https://github.com/maehw/tt02-bcd-7segment-encoder"
        },
        "documentation": {
            "author": "maehw",
            "discord": "maehw#7519",
            "title": "BCD to 7-segment encoder",
            "description": "Encode binary coded decimals (BCD) in the range 0..9 to 7-segment display control signals",
            "how_it_works": "The design has been fully generated using https://github.com/maehw/wokwi-lookup-table-generator using a truth table (https://github.com/maehw/wokwi-lookup-table-generator/blob/main/demos/bcd_7segment_lut.logic.json). The truth table describes the translation of binary coded decimal (BCD) numbers to wokwi 7-segment display (https://docs.wokwi.com/parts/wokwi-7segment). Valid BCD input values are in the range 0..9, other values will show a blank display.",
            "how_to_test": "Control the input switches on the PCB and check the digit displayed on the 7-segment display.",
            "external_hw": "Input switches and 7-segment display (should be on the PCB)",
            "language": "wokwi",
            "doc_link": "https://github.com/maehw/wokwi-lookup-table-generator/blob/main/README.md",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "w",
                "x",
                "y",
                "z",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "342981109408072274",
            "git_url": "https://github.com/benevpi/tt02-LED-flasher"
        },
        "documentation": {
            "author": "Ben Everard",
            "discord": "benev2",
            "title": "A LED Flasher",
            "description": "Select different inputs to generate different LED patterns",
            "how_it_works": "see How To Test",
            "how_to_test": " input 1 - clock input input 2 - feed NOT LED 1 back into the shift register -- this creates a pattern where every other LED is switched on input 3 - feed 1 into the shift register if both the first two LEDs are off. This creates a pattern where every third LED is on input 4 - feed 1 into the shift register if the first three LEDs are off. This creates a pattern where every fourth LED is on input 5 - feed 1 into the shift register if all the LEDs are off. This creates a pattern of one light scanning across the LEDs input 6 - set the direction of the shift register input 7 - toggles fixed direction or alternating direction. If alternating direction is set, the direction of the shift register will flip if all the LEDs are off input 8 - enable the clock divider",
            "external_hw": "A LED on each pin",
            "language": "wokwi",
            "doc_link": "https://github.com/benevpi/tt02-LED-flasher/blob/main/README.md",
            "clock_hz": 0,
            "picture": "https://github.com/benevpi/tt02-LED-flasher/tree/main",
            "inputs": [
                "clock",
                "not_1",
                "not_1_2",
                "not_1_2_3",
                "not_all",
                "direction",
                "toggle_direction",
                "clock_div_enable"
            ],
            "outputs": [
                "LED1",
                "LED2",
                "LED3",
                "LED4",
                "LED5",
                "LED6",
                "LED7",
                "LED8"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "bit_full_adder.v",
                "n_bit_adder.v",
                "seg7.v",
                "multiplier.v",
                "asic_multiplier.v",
                "asic_multiplier_wrapper.v"
            ],
            "top_module": "asic_multiplier_wrapper",
            "git_url": "https://github.com/kuriousd/tt02-4bit-multiplier"
        },
        "documentation": {
            "author": "Fernando Dominguez Pousa",
            "discord": "CuriosoD",
            "title": "4-bit Multiplier",
            "description": "4-bit Multiplier based on single bit full adders",
            "how_it_works": "Inputs to the multiplier are provided with the switch. As only eight inputs are available including clock and reset, only three bits remain available for each multiplication factor. Thus, a bit zero is set as the fourth bit. The output product is showed in the 7 segment display. Inputs are registered and a product is calculated. As output is 8-bit number, every 500ms a number appears. First the less significant 4 bits, after 500ms the most significant. When less significant 4-bits are displayed, the led dot including in the display is powered on.",
            "how_to_test": "HDL code is tested using Makefile and cocotb. 4 set of tests are included: the single bit adder, the 4-bit adder, the 4-bit multiplier and the top design. In real hardware, the three less significant bits can create a number times the number created with the next three bits. Reset is asserted with the seventh bit of the switch.",
            "external_hw": "Clock divider to 2500 Hz. Seven segment display with dot led. 8-bit DIP Switch",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 2500,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "i_factor_a[0]",
                "i_factor_a[1]",
                "i_factor_a[2]",
                "i_factor_b[3]",
                "i_factor_b[4]",
                "i_factor_b[5]"
            ],
            "outputs": [
                "segment_1 (o_segments[0])",
                "segment_2 (o_segments[1])",
                "segment_3 (o_segments[2])",
                "segment_4 (o_segments[3])",
                "segment_5 (o_segments[4])",
                "segment_6 (o_segments[5])",
                "segment_7 (o_segments[6])",
                "segment_dot (o_lsb_digit)"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "toplevel/logisimTopLevelShell.v",
                "circuit/main.v",
                "circuit/tone_generator.v",
                "circuit/tone_generator_2.v",
                "circuit/triangle_wave_generator.v",
                "gates/AND_GATE.v",
                "gates/AND_GATE_BUS.v",
                "gates/OR_GATE.v",
                "gates/XNOR_GATE_ONEHOT.v",
                "gates/XOR_GATE_ONEHOT.v",
                "memory/D_FLIPFLOP.v",
                "memory/REGISTER_FLIP_FLOP.v",
                "plexers/Demultiplexer_16.v",
                "arith/Adder.v"
            ],
            "top_module": "tholin_avalonsemi_tbb1143",
            "git_url": "https://github.com/89Mods/tt2-avalonsemi-TBB1143"
        },
        "documentation": {
            "discord": "Tholin#7559",
            "author": "Tholin",
            "title": "Avalon Semiconductors 'TBB1143' Programmable Sound Generator",
            "description": "Sound generator with two square-wave voices, one sawtooth voice and one noise channel. Can also be used as a general-purpose frequency generator.",
            "how_it_works": "All tone generators simply take the input clock frequency, multiplied by 256 and divide it by 16 times the generator's divisor setting. It does this by using a ring oscillator to generate a faster internal clock to be able to generate a wider range of tones. Of course, the outputs are stil only updated as fast as the scan chain allows. The output is a 6-bit digital sample, but can easily be converted to an analog signal using a resistor chain. Also uses the leftover output pins as general-purpose outputs.",
            "how_to_test": "It is possible to use the DIP switches to program the generator according to the documentation. Writing 1101 into address 1, 1010 into address 2, 0000 into address 3 and finally 0001 into address 15 will cause a ~440Hz tone to appear on the output.",
            "external_hw": "Lots of resistors or some other DAC, as well as a microprocessor or microcontroller to program the 1143.",
            "language": "verilog",
            "doc_link": "https://github.com/AvalonSemiconductors/tt2-avalonsemi-TBB1143/blob/main/README.md",
            "clock_hz": 6000,
            "picture": "",
            "inputs": [
                "CLK",
                "RST",
                "D0",
                "D1",
                "D2",
                "D3",
                "A0",
                "WRT"
            ],
            "outputs": [
                "SOUT0",
                "SOUT1",
                "T0",
                "T1",
                "T2",
                "T3",
                "LED0",
                "LED1"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "tomkeddie_top_tto_a.v",
                "uart_tx.v"
            ],
            "top_module": "tomkeddie_top_tto_a",
            "git_url": "https://github.com/TomKeddie/tinytapeout-2022-2a"
        },
        "documentation": {
            "author": "Tom Keddie",
            "discord": "TomKeddie#7070",
            "title": "Transmit UART",
            "description": "Transmits a async serial string on a pin",
            "how_it_works": "Sends an async uart message on severals pins",
            "how_to_test": "Attach a uart receiver to each pins, set the baud rate to 1200 and read the messages",
            "external_hw": "Serial cable",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1200,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "uart_tx_0",
                "uart_tx_1",
                "uart_tx_2",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "ledmatrix.v"
            ],
            "top_module": "mm21_LEDMatrixTop",
            "git_url": "https://github.com/mm21/tinytapeout2-led-matrix"
        },
        "documentation": {
            "author": "Matt M",
            "discord": "",
            "title": "RGB LED Matrix Driver",
            "description": "Drives a simple animation on SparkFun's RGB LED 8x8 matrix backpack",
            "how_it_works": "Implements an SPI master to drive an animation with overlapping green/blue waves and a moving white diagonal. Some 7-segment wires are used for a 'sanity check' animation.",
            "how_to_test": "Wire accordingly and use a clock up to 12.5 KHz. Asynchronous reset is synchronized to the clock.",
            "external_hw": "RGB LED matrix backpack from SparkFun: https://www.sparkfun.com/products/retired/760",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 6250,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "SCLK",
                "MOSI",
                "segment c",
                "segment d",
                "segment e",
                "nCS",
                "segment g",
                "none (always high)"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "348195845106041428",
            "git_url": "https://github.com/argunda/tt02-TinyPFD"
        },
        "documentation": {
            "author": "argunda",
            "discord": "catbeans",
            "title": "Tiny Phase/Frequency Detector",
            "description": "Detect phase shifts between 2 square waves.",
            "how_it_works": "This is one of the blocks of a phased locked loop. The inputs are a reference clock and feedback clock and the outputs are the phase difference on either up or /down pin.",
            "how_to_test": "If the phase of the feedback clock is leading the reference clock, the up signal should show the phase difference. If it's lagging, the down signal will show the difference.",
            "external_hw": "Signal generators for square wave inputs.",
            "language": "wokwi",
            "doc_link": "https://ieeexplore.ieee.org/document/278348?subid1=20221113-1837-0613-a274-db851cd8a2cb",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "reference clock",
                "feedback clock",
                "active-low reset",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "up",
                "(inverted) down",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "348121131386929746",
            "git_url": "https://github.com/meriac/loading-animation"
        },
        "documentation": {
            "author": "Andre & Milosch Meriac",
            "discord": "FoolsDelight",
            "title": "Loading Animation",
            "description": "Submission for tt02 - Rotating Dash",
            "how_it_works": "Slide switch to external clock. All DIP switches to off. DIP2 (Reset) on to run (Reset is low-active). By switching DIP3 (Mode) on and setting the sliding switch to Step-Button, the Step-Button can be now used to animate step by step.",
            "how_to_test": "Slide switch to external clock. All DIP switches to off. DIP2 (Reset) on to run (Reset is low-active).",
            "external_hw": "Default PCB",
            "language": "wokwi",
            "doc_link": "https://github.com/meriac/loading-animation/blob/main/README.md",
            "clock_hz": 10000,
            "picture": "img/loading-animation.png",
            "inputs": [
                "clock",
                "reset",
                "mode",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "yubex_egg_timer.v"
            ],
            "top_module": "yubex_egg_timer",
            "git_url": "https://github.com/yubex/tt02-tiny_egg_timer"
        },
        "documentation": {
            "author": "yubex",
            "discord": "",
            "title": "tiny egg timer",
            "description": "tiny egg timer is a configurable small timer",
            "how_it_works": "Its a simple FSM with 3 states (Idle, Waiting and Alarm) and counters regarding clk_cycles, seconds and minutes...",
            "how_to_test": "Set the clock to 10kHz, set the wait time you want (in minutes) by setting io_in[7:3], set the start switch to 1, the timer should be running, the dot of the 7segment display should toggle each second. If the time is expired, an A for alarm should be displayed. You can stop the alarm by setting the start switch to 0 again.",
            "external_hw": "no external hw requrired",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 10000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "start",
                "wait time in minutes [0]",
                "wait time in minutes [1]",
                "wait time in minutes [2]",
                "wait time in minutes [3]",
                "wait time in minutes [4]"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "dot"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "potato1.v"
            ],
            "top_module": "xyz_peppergray_Potato1_top",
            "git_url": "https://github.com/peppergrayxyz/Potato-1"
        },
        "documentation": {
            "author": "Pepper Gray (they/them)",
            "title": "Potato-1 (Brainfuck CPU)",
            "description": "Potato-1 is part of a Brainfuck CPU. It is only the control logic, i.e. you have to bring your own registers, memory controller and io logic. It is very simple, hence likely very slow: You could probably run your brainfuck code on a potato and it would be equally fast, hence the name. The project picture was generated using DALL\u00b7E.\n",
            "how_it_works": "Each rising edge the CU will read in the instruction, zero flag and IO Wait flag and process it. Each falling edge the output pins will be updated. The output pins indiciate which action to take, i.e. which registers to increment/decrement. If Put or Get pin is set, the CU will pause execution until IO Wait is unset. If IO Wait is already unset, the CU will immidiatly execute the next command without waiting.\n\nAdditionaly to the 8 original brainfuck instructions there is a HALT instruction to stop execution and a NOP instructions to do nothing, also there are unused instruction (some of them may be used to extend the instruction set in a later itteration).\n\nInstructions:\n  0000  >       Increment the data pointer \n  0001  <       Decrement data pointer\n  0010  +       Increment value\n  0011  -       Decrement value\n  0100  .       Write value\n  0101  ,       Read value\n  0110  [       Start Loop (enter if value is non-zero, else jump to matchin ']')\n  0111  ]       End Loop (leave if value is zero, , else jump to matchin '[')\n  1000  NOP     No Operation\n  1111  HALT    Halt Execution\n",
            "how_to_test": "Reset: \n  Set Reset_n=0 and wait one clockycycle\n\nRun: \n  Set Reset_n=1\n\nSimple Test:\n  - all input pins zero\n  - clock cycle\n  - Reset_n high\n  - clock cylce\n  --> PC++ high, all outer outputs are low\n \nCheck test/test.py for small scripts to verify the CU logic\n",
            "external_hw": "Bidirectional Counter (3x)\n  - program counter\n  - data pointer\n  - value\nROM (addressed via programm counter)\nRAM (addressed via data pointer, all bytes must be zero after reset)\n\nsome TTL gates, e.g. to configure that the value is written to RAM every time it is changed or the data pointer is changed\n",
            "language": "verilog",
            "doc_link": "https://github.com/peppergrayxyz/Potato-1",
            "clock_hz": 12500,
            "picture": "doc/potato1.png",
            "inputs": [
                "Clock",
                "Reset_n",
                "IO Wait",
                "Zero Flag",
                "Instruction[0]",
                "Instruction[1]",
                "Instruction[2]",
                "Instruction[3]"
            ],
            "outputs": [
                "PC++",
                "PC--",
                "X++",
                "X--",
                "A++",
                "A--",
                "Put",
                "Get"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "zoechip.v"
            ],
            "top_module": "zoechip",
            "git_url": "https://github.com/zoent/tt02-zoe-chip"
        },
        "documentation": {
            "author": "zoe nguyen.  taylor",
            "discord": "",
            "title": "heart zoe mom dad",
            "description": "outputs my name and my age (zoe 4)",
            "how_it_works": "spells leters",
            "how_to_test": "shift 1 hot value",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "Z",
                "O",
                "E",
                "F",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "348255968419643987",
            "git_url": "https://github.com/nanikgeorge/tt02-submission-template"
        },
        "documentation": {
            "author": "Nanik Adnani",
            "discord": "nanik",
            "title": "Tiny Synth",
            "description": "A tiny synthesizer! Modulates the frequency of the clock based on inputs, plays a C scale (hopefully).",
            "how_it_works": "Will come back and write more after my exams!",
            "how_to_test": "Make sure the clock is tied to input 0, whatever frequency you want, play with it! Then you can play different notes by toggling the other inputs.",
            "external_hw": "Not entirely sure yet, it outputs a square wave, I still need to figure out what to do with it to make it make sound.",
            "language": "wokwi",
            "doc_link": "Not done yet, eventually!",
            "clock_hz": 12500,
            "picture": "Not done yet.",
            "inputs": [
                "clock",
                "C",
                "D",
                "E",
                "F",
                "G",
                "A",
                "B"
            ],
            "outputs": [
                "Pitch + 1 Octave",
                "Pitch",
                "Pitch - 1 Octave",
                "Pitch - 2 Octave",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "mbikovitsky_top.v",
                "lfsr.v",
                "seven_segment.v",
                "uart.v",
                "ram.v",
                "alu.v",
                "extend_alu.v",
                "cpu.v"
            ],
            "top_module": "mbikovitsky_top",
            "git_url": "https://github.com/mbikovitsky/tt02-lfsr"
        },
        "documentation": {
            "author": "Michael Bikovitsky",
            "discord": "",
            "title": "5-bit Galois LFSR",
            "description": "5-bit Galois LFSR with configurable taps and initial state. Outputs a value every second.",
            "how_it_works": "https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Galois_LFSRs",
            "how_to_test": "1. Set the desired taps using the switches\n2. Assert the reset_taps pin\n3. Deassert reset_taps\n4. Set the desired initial state\n5. Assert reset_lfsr\n6. Deassert reset_lfsr\n7. Look at it go!\n   - Values between 0x00-0x0F are output as hex digits.\n   - Values between 0x10-0x1F are output as hex digits with a dot.\n8. Did you know there is a secret CPU inside?\n",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 625,
            "picture": "",
            "inputs": [
                "clock",
                "reset_lfsr",
                "reset_taps",
                "data_in1",
                "data_in2",
                "data_in3",
                "data_in4",
                "data_in5"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment p"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "348260124451668562",
            "git_url": "https://github.com/teaandtechtime/tt02-submission-prbs15"
        },
        "documentation": {
            "author": "Tom Schucker",
            "discord": "tdsepsilon",
            "title": "prbs15",
            "description": "generates and checks prbs15 sequences",
            "how_it_works": "uses lfsr to generate and check prbs15 sequence",
            "how_to_test": "running clk, gnd pin1, set enable high. feedback prbs15 output to check, monitor error for pulses",
            "external_hw": "logic analyzer and jumper leads",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "gnd",
                "enable",
                "check",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "clk",
                "prbs15",
                "error",
                "checked",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "fsm.v",
                "top.v"
            ],
            "top_module": "rolfmobile99_alu_fsm_top",
            "git_url": "https://github.com/rolfmobile99/tt02-submission-template"
        },
        "documentation": {
            "author": "Rolf Widenfelt",
            "discord": "",
            "title": "4-bit badge ALU",
            "description": "A 4-bit ALU inspired by Supercon.6 badge",
            "how_it_works": "finite state machine with combinational logic (in verilog)",
            "how_to_test": "cocotb",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clk",
                "rst",
                "ctl",
                "none",
                "datain3",
                "datain2",
                "datain1",
                "datain0"
            ],
            "outputs": [
                "none",
                "none",
                "none",
                "cout",
                "alu3",
                "alu2",
                "alu1",
                "alu0"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "jar_pi.v",
                "decoder.v"
            ],
            "top_module": "jar_pi",
            "git_url": "https://github.com/jar/tt02_freespeech"
        },
        "documentation": {
            "author": "James Ross",
            "discord": "jar#1709",
            "title": "Pi (\u03c0) to 1000+ decimal places",
            "description": "This circuit outputs the first 1024 decimal digits of Pi (\u03c0), including the decimal after the three. The repository started out as something else, but after completing the 16x8 SRAM circiut (128 bits), I became curious about just how much information could be packed into the circuit area.  The D flip flops in SRAM aren't particularly dense and the circuit has other functionality beyond information storage.  For this demonstration, I needed something without a logical pattern, something familiar, and something which would exercise all the LEDs in the seven segment display.  The Pi constant was perfect.  After a number of experiments in Verilog, trying the Espresso Heuristic Logic Minimizer tool, the best results ended up being a large boring block of case statements and letting the toolchain figure it out. The information limit I found was 1023*log2(10)+1 ~= 3,400 bits, after which the toolchain struggled.  However, it appears in this case that the layout is limited by metal, not combinatorial logic.  I am interested to hear about better strategies to do something like this with synthesizable Verilog.",
            "how_it_works": "There is some combinatorial logic which generates the first 1024 decimal digits and then decodes those digits (and the decimal) to the 7 segment display.",
            "how_to_test": "The clock is used to drive the incremental changes in the display.  The reset pin is used to zero the index.",
            "external_hw": "The seven segment display is used directly.",
            "language": "verilog",
            "doc_link": "https://github.com/jar/tt02_freespeech/blob/main/README.md",
            "clock_hz": 0,
            "picture": "pi.png",
            "inputs": [
                "clk",
                "reset",
                null,
                null,
                null,
                null,
                null,
                null
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "decimal LED"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "348242239268323922",
            "git_url": "https://github.com/alanvgreen/tt02-siren"
        },
        "documentation": {
            "author": "Alan Green",
            "discord": "AlanGreen#3623",
            "title": "Siren",
            "description": "Pretty patterns and a siren straight from the 1970s",
            "how_it_works": "A long chain of D flip flops divides down the clock to produce a range of frequencies  that are used for various purposes.\nSome of the higher frequencies are used to produce the tones. Lower frequencies are used to control the patterns of lights and to change the tones being sent to the speaker.\nAn interesting part of the project is a counter that counts to 5 and resets to zero. This is used for one of the two patterns of lights, where the period of pattern is six.\n",
            "how_to_test": "Connect a speaker to the last digital output pin, the one which is also connected to the decimal point on the seven segment display. Switch 8 is used to select between two groups of patterns.\n",
            "external_hw": "For the audio output on pin 7, either use an audio amplifier or, if bravely connecting a speaker directly, place a resistor in series to limit the current.\n",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 12500,
            "picture": "",
            "inputs": [
                "clock",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "pattern_select"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "spade.sv",
                "wrapper.v"
            ],
            "top_module": "thezoq2_yafpga",
            "git_url": "https://github.com/TheZoq2/smolfpga"
        },
        "documentation": {
            "author": "Frans Skarman",
            "discord": "TheZoq2",
            "title": "YaFPGA",
            "description": "Yet another FPGA",
            "how_it_works": "TODO",
            "how_to_test": "TODO",
            "external_hw": "",
            "language": "Spade",
            "doc_link": "TODO",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "input1",
                "input2",
                "input3",
                "input4",
                "config data",
                "config clock",
                "none"
            ],
            "outputs": [
                "output0",
                "output1",
                "output2",
                "output3",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "counter.v",
                "decoder.v",
                "moyes0.v"
            ],
            "top_module": "moyes0_top_module",
            "git_url": "https://github.com/moyesw/TT02-M0"
        },
        "documentation": {
            "author": "William Moyes",
            "discord": "WilliamM#5615",
            "title": "M0: A 16-bit SUBLEQ Microprocessor",
            "description": "A capable but slow microprocessor that fits in a very tight space",
            "how_it_works": "The M0 is a 16-bit, bit serial microprocessor based upon the SUBLEQ architecture. The only external devices needed for operation are a SPI RAM, SPI ROM, and clock source. The entire ROM and RAM are available for user code.  All registers and logic are contained within the M0 itself. A transmit UART is included for serial output. The M0 interoperates with Oleg Mazonka's HSQ C-compiler for SUBLEQ. See https://github.com/moyesw/TT02-M0/blob/main/README.md for full details on the M0.",
            "how_to_test": "Easy check #1 without RAM/ROM chips- Assert Reset High (input1). Hold spi_miso low (input2). Apply a slow clock to both CLK (input0) and DBG_in (input7). Bring Reset Low. Examine the inverted clock output on output7 (DBG_OUT), and compare to clk on in0 to determine io scan chain quality. Examine spi_clk on out3. There should be 40 spi clock pulses at half the clk input frequency, followed by a 2 spi clock gap where no pulses are present.\n\nEasy check #2 without RAM/ROM chips- Assert Reset high (input2). Hold spi_miso low. Apply a clock to CLK (input0). Bring Reset Low. Allow the M0 to reach steady state (504 clock cycles from reset). Observe the UART transmits 0xFF every 504 input clock cycles on output4. Observe that the CS0 and CS1 are accessed in the pattern: CS1, CS1, CS0, CS1, CS1, CS0. Observe that the CS0+1 and the spi_mosi pin encodes the following repeating SPI access pattern: CS1:Rd(03):Addr(FFFE), CS1:Rd(03):Addr(FFFE), CS0:Rd(03):Addr(0000), CS1:Rd(03):Addr(FFFE), CS1:Wr(02):Addr(FFFE), CS0:Rd(03):Addr(8000). Note Each access will be accompanied by 16/17 bits of data movement.\n\nRunning code with RAM/ROM chips- Connect a programmed SPI ROM to CS1, and a SPI RAM to CS0. Assert Reset. Power up the ASIC and provide a clock. Lower Reset, and observe execution. The program's serial output will appear on output pin 4 at a baud rate that is one half the input clock frequency. See https://github.com/moyesw/TT02-M0/blob/main/README.md for information on external connections, ROM and RAM data formats, instruction set, and compiler usage.\n",
            "external_hw": "A SPI ROM and RAM for user code",
            "language": "verilog",
            "doc_link": "https://github.com/moyesw/TT02-M0/blob/main/README.md",
            "clock_hz": 12500,
            "picture": "hello_c.png",
            "inputs": [
                "clk",
                "rst",
                "spi_miso",
                "none",
                "none",
                "none",
                "none",
                "dbg_in"
            ],
            "outputs": [
                "spi_cs0",
                "spi_cs1",
                "spi_clk",
                "spi_mosi",
                "uart_tx",
                "none",
                "none",
                "dbg_out"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "yupferris_bitslam.v"
            ],
            "top_module": "yupferris_bitslam",
            "git_url": "https://github.com/yupferris/bitslam"
        },
        "documentation": {
            "author": "Jake \"ferris\" Taylor",
            "discord": "yupferris#1454",
            "title": "bitslam",
            "description": "bitslam is a programmable sound chip with 2 LFSR voices.",
            "how_it_works": "bitslam is programmed via its register write interface. A register write is performed by first writing an internal address register, which selects which register will be written to, and then writing a value. Bit 1 distinguishes address writes (0) or data writes (1). Address bits 1-2 address different internal modules: 00 addresses voice 0, 01 addresses voice 1, and 10 addresses the mixer. Address bit 0 addresses a register in the internal module. Each voice is controlled by a clock divider and a tap mask for the LFSR state. The clock divider is at address 0 and controls the rate at which the LFSR is updated, effectively controlling the pitch. Since bitslam is (expected to be) clocked at 6khz, the pitch will be determined by 3khz / x where x is the 6-bit clock divider value. Each voice also contains a 4-bit LFSR tap mask (address 1) which determines which of 4 LFSR bits are XOR'd together to determine the new LFSR LSB. The LFSR is 10 bits wide and the tap mask bits correspond to positions 1, 4, 6, and 9, respectively. The mixer has a single register to control the volume of each voice. Bits 0-2 determine voice 0 volume, and bits 3-5 determine voice 1 volume. A value of 0 means a voice is silent, and a value of 7 is full volume. Special thanks to Daniel \"trilader\" Schulte for pointing out a crucial interconnect bug.",
            "how_to_test": "bitslam is meant to be driven and clocked by an external host, eg. a microcontroller. The microcontroller should use the register write interface described above to program the desired audio output (eg. to play a song or sound effects) and 4-bit digital audio should be generated on the 4 digital out pins.",
            "external_hw": "A 4-bit DAC connected to the four digital output pins.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 6000,
            "picture": "",
            "inputs": [
                "clock",
                "address/data selector",
                "address/data 0",
                "address/data 1",
                "address/data 2",
                "address/data 3",
                "address/data 4",
                "address/data 5"
            ],
            "outputs": [
                "digital out 0",
                "digital out 1",
                "digital out 2",
                "digital out 3",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341620484740219475",
            "git_url": "https://github.com/ThorKn/tinytapeout02_pattern_player"
        },
        "documentation": {
            "author": "Thorsten Knoll",
            "discord": "",
            "title": "8x8 Bit Pattern Player",
            "description": "8x8 bit serial programmable, addressable and playable memory.",
            "how_it_works": "The 8x8 memory is a 64-bit shiftregister, consisting of 64 serial chained D-FlipFlops (data: IN0, clk_sr: IN1). 8 memoryslots of each 8 bit can be directly addressed via addresslines (3 bit: IN2, IN3, IN4) or from a clockdriven player (3 bit counter, clk_pl: IN7). A mode selector line (mode: IN5) sets the operation mode to addressing or to player. The 8 outputs are driven by the 8 bit of the addressed memoryslot.",
            "how_to_test": "Programm the memory: Start by filling the 64 bit shiftregister via data and clk_sr, each rising edge on clk_sr shifts a new data bit into the register. Select mode: Set mode input for direct addressing or clockdriven player. Address mode: Address a memoryslot via the three addresslines and watch the memoryslot at the outputs. Player mode: Each rising edge at clk_pl enables the next memoryslot to the outputs.",
            "external_hw": "You could programm, address and play the 8x8 Bit Pattern Player with a breadboard, two clock buttons and some dipswitches on the input side. Add some LED to the output side. Just like the WOKWI simulation.",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "pattern_player.png",
            "inputs": [
                "data",
                "clk_sr",
                "address_0",
                "address_1",
                "address_2",
                "mode",
                "none",
                "clk_pl"
            ],
            "outputs": [
                "bit 0",
                "bit 1",
                "bit 2",
                "bit 3",
                "bit 4",
                "bit 5",
                "bit 6",
                "bit 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "user_module.v",
                "top.v"
            ],
            "top_module": "github_com_proppy_tt02_xls_popcount",
            "git_url": "https://github.com/proppy/tt02-xls-popcount"
        },
        "documentation": {
            "author": "proppy",
            "discord": "proppy",
            "title": "XLS: bit population count",
            "description": "Count bits set in the input.",
            "how_it_works": "https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel",
            "how_to_test": "Pull up input bits, check that output bits represent the count.",
            "external_hw": "LEDs and resistors",
            "language": "XLS",
            "doc_link": "https://github.com/proppy/tt02-xls-popcount/blob/main/README.md",
            "clock_hz": 0,
            "picture": "popcount.svg",
            "inputs": [
                "bit0",
                "bit1",
                "bit2",
                "bit3",
                "bit4",
                "bit5",
                "bit6",
                "bit7"
            ],
            "outputs": [
                "count0",
                "count1",
                "count2",
                "count3",
                "count4",
                "count5",
                "count6",
                "count7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "rc5.v",
                "decoder.v",
                "rc5_top.v"
            ],
            "top_module": "rc5_top",
            "git_url": "https://github.com/jeanthom/tt02-rc5-receiver"
        },
        "documentation": {
            "author": "Jean THOMAS",
            "discord": "",
            "title": "RC5 decoder",
            "description": "Increment/decrement a counter with the press of an IR remote button!",
            "how_it_works": "Decodes an RC5 remote signal, increments the counter if the volume up button is pressed, decrements the counter if the volume down button is pressed",
            "how_to_test": "After reset, point a remote to the IR receiver. Press the volume up button and the display count should increase.",
            "external_hw": "Connect an IR demodulator (ie. TSOP1738) to the input pin",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 562,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "IR demodulator output",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341614374571475540",
            "git_url": "https://github.com/mmolteni-secpat/tinytapeout02_chiDOM"
        },
        "documentation": {
            "author": "Maria CHiara Molteni",
            "discord": "Mari-secpat",
            "title": "chiDOM",
            "description": "Chi function of Xoodoo protected at the first-order by DOM",
            "how_it_works": "Chi function of Xoodoo protected at the first-order by DOM",
            "how_to_test": "Set on all the inputs",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "player.v",
                "tune.v"
            ],
            "top_module": "meriac_tt02_play_tune",
            "git_url": "https://github.com/meriac/tt02-play-tune"
        },
        "documentation": {
            "author": "Milosch Meriac",
            "discord": "FoolsDelight",
            "title": "Super Mario Tune on A Piezo Speaker",
            "description": "Plays Super Mario Tune over a Piezo Speaker connected across io_out[1:0]",
            "how_it_works": "Converts an RTTL ringtone into verilog using Python - and plays it back using differential PWM modulation",
            "how_to_test": "Provide 3kHz clock on io_in[0], briefly hit reset io_in[1] (L->H->L) and io_out[1:0] will play a differential sound wave over piezo speaker (Super Mario)",
            "external_hw": "Piezo speaker connected across io_out[1:0]",
            "language": "verilog",
            "doc_link": "https://github.com/meriac/tt02-play-tune#readme",
            "clock_hz": 3125,
            "picture": "img/chip-design.png",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "piezo_speaker_p",
                "piezo_speaker_n",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "counter.v",
                "decoder.v"
            ],
            "top_module": "phasenoisepon_seven_segment_seconds",
            "git_url": "https://github.com/phasenoisepon/tt02-phasenoisepon"
        },
        "documentation": {
            "author": "Phase Noise",
            "discord": "@PhaseNoisePega",
            "title": "Tiny rot13",
            "description": "implements rot13 in the constraints of TT02",
            "how_it_works": "shifts in low and high nibble to construct an ASCII character, performs rot13, then outputs. The design uses some registers to store the low and high nibbles before constructing them into the ASCII character. ROT13 is implemented with a LUT genetated from Python. Controlled using control lines instead of specific clock cycles. Any non-alphabetic characters are passed through",
            "how_to_test": "CTL0 and CTL1 are control lines. Let CTL[1:0], 2b00 -> Shift in low nibble on D[3:0] and set output[7:0]=0x0f, 2b01 -> Shift in high nibble on D[3:0] and set output[7:0]=0xf0, 2b1X -> Shift out S on output[7:0]. Shift in the low and high nibbles of rot13, then read the result on the next cycle. Internal registers are init to 0, so by default after a RST, the output will be 0x00 for a single cycle(if CTL=2'b10), otherwise it will 2'b00 before updating to whatever the control lines set it to. Every operation effectively sets the output of the next clock cycle. Every complete operation effectively takes 4 cycles. To test, Set RST, then write 0x1 as the low nibble (clock 0), 0x4 as the high nibble (clock 1), then set the control lines to output (clock 1). 0x4e should be read at clock 4, with the output sequence being C=0 out=0x00, C=1 out=0x01, C=2 out=0x10, C=3 out=0x4e. 0x00 should produce 0x00 while 0x7f should produce 0x7f.",
            "external_hw": "For basic usage, the carrier board should suffice. An MCU or FPGA would be required to use this to the fullest extent, and an FPGA with PCIe would let you build the world's worst ROT13 Accelerator!",
            "language": "verilog",
            "doc_link": "https://github.com/phasenoisepon/tt02-phasenoisepon/blob/main/README.md",
            "clock_hz": 1000,
            "picture": "./ROT13.png",
            "inputs": [
                "clock",
                "reset - Resets the system to a clean state",
                "CTL0 - LSB of control",
                "CTL1 - MSB of control",
                "D0 - LSB of input nibble",
                "D1",
                "D2",
                "D3 - MSB of input nibble"
            ],
            "outputs": [
                "DO0 - LSB of output",
                "DO1",
                "DO2",
                "DO3",
                "DO4",
                "DO5",
                "DO6",
                "DO7 - MSB of output"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341541108650607187",
            "git_url": "https://github.com/13arn/tt02_counter_steamdeck"
        },
        "documentation": {
            "author": "13arn",
            "discord": "13arn#9121",
            "title": "4 bit counter on steamdeck",
            "description": "copy of my tt01 submission, enable first input and press button to use the counter",
            "how_it_works": "fsm that uses 1 input to progress abd count from 0 to 3. Other inputs have various logic to play with",
            "how_to_test": "enable first input so it is on and connected to the button. All other inputs are off. Press button to progress the fsm.",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341516949939814994",
            "git_url": "https://github.com/ThorKn/tinytapeout02_shiftregister_challenge"
        },
        "documentation": {
            "author": "Thorsten Knoll",
            "discord": "",
            "title": "Shiftregister Challenge 40 Bit",
            "description": "The design is a 40 bit shiftregister with a hardcoded 40 bit number. The challenge is to find the correct 40 bit to enable the output to high. With all other numbers the output will be low.",
            "how_it_works": "Shift a 40 bit number into the chip with the two inputs data (IN0) and clk (IN1). If the shifted 40 bit match the hardcoded internal 40 bit, then and only then the output will become high. Having only the mikrochip without the design files, one might need reverse engineering and/or side channel attacks to fing the correct 40 bit.",
            "how_to_test": "Get the correct 40 bit from the design and shift them into the shiftregister. Each rising edge at the clk will push the next bit into the register. At the correct 40 bit, the output will enable high.",
            "external_hw": "To test when knowing the correct 40 bit, only a dipswitch (data), a button (clk) and a LED (output) is needed. Without knowing the number it becomes the challenge and more hardware might be required.",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "shiftregister_challenge.png",
            "inputs": [
                "data",
                "clk",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "output",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "toplevel/logisimTopLevelShell.v",
                "circuit/main.v",
                "arith/Adder.v",
                "gates/AND_GATE_BUS.v"
            ],
            "top_module": "tt2_tholin_multiplier",
            "git_url": "https://github.com/89Mods/tt2-4x4-multiply"
        },
        "documentation": {
            "discord": "Tholin#7559",
            "author": "Tholin",
            "title": "TinyTapeout2 4-bit multiplier.",
            "description": "Multiplies two 4-bit numbers presented on the input pins and outputs an 8-bit result.",
            "how_it_works": "The multiplier is implemented using purely combinatorial logic. One 6-bit adder and two 8-bit adders as well as a heap of AND gates are the only used components.",
            "how_to_test": "Input any two numbers on the input ports, and check if the 8-bit result is correct.",
            "external_hw": "DIP switches for the inputs, and LEDs on the outputs, to be able to read the binary result.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 6000,
            "picture": "circuit.png",
            "inputs": [
                "A0",
                "A1",
                "A2",
                "A3",
                "B0",
                "B1",
                "B2",
                "B3"
            ],
            "outputs": [
                "R0",
                "R1",
                "R2",
                "R3",
                "R4",
                "R5",
                "R6",
                "R7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "toplevel/logisimTopLevelShell.v",
                "circuit/main.v",
                "circuit/bcd_to_seg.v",
                "circuit/seconds_counter.v",
                "circuit/full_counter.v",
                "circuit/custom_counter_3.v",
                "circuit/custom_counter_4.v",
                "circuit/custom_counter_10.v",
                "arith/Comparator.v",
                "gates/AND_GATE.v",
                "gates/OR_GATE.v",
                "memory/D_FLIPFLOP.v",
                "plexers/Multiplexer_bus_4.v"
            ],
            "top_module": "tt2_tholin_multiplexed_counter",
            "git_url": "https://github.com/89Mods/tt2-multiplexed-counter"
        },
        "documentation": {
            "discord": "Tholin#7559",
            "author": "Tholin",
            "title": "TinyTapeout2 multiplexed segment display timer.",
            "description": "Measures time up to 99 minutes and 59 seconds by multiplexing 4 seven-segment displays.",
            "how_it_works": "TODO",
            "how_to_test": "TODO",
            "external_hw": "4 sevent segment displays, plus some 74-series chips to build the select logic.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1024,
            "picture": "",
            "inputs": [
                "CLK",
                "RST",
                "NC",
                "NC",
                "NC",
                "NC",
                "NC",
                "NC"
            ],
            "outputs": [
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "SEL"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "top.v",
                "user_module.v"
            ],
            "top_module": "github_com_proppy_tt02_xls_counter",
            "git_url": "https://github.com/proppy/tt02-xls-counter"
        },
        "documentation": {
            "author": "proppy",
            "discord": "proppy",
            "title": "XLS: 8-bit counter",
            "description": "Increment output bits",
            "how_it_works": "Implement a simple counter using https://google.github.io/xls/tutorials/intro_to_procs/",
            "how_to_test": "Set the reset bit once, toggle the clock once, unset the reset bit and keep toggling the clock",
            "external_hw": "LEDs, pull-up/down resistors",
            "language": "XLS",
            "doc_link": "https://github.com/proppy/tt02-xls-counter/blob/main/README.md",
            "clock_hz": 10,
            "picture": "counter.svg",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "count0",
                "count1",
                "count2",
                "count3",
                "count4",
                "count5",
                "count6",
                "count7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "counter.v",
                "decoder.v"
            ],
            "top_module": "xor_shift32_quantamhd",
            "git_url": "https://github.com/QuantamHD/ethan-evan-random-numbers"
        },
        "documentation": {
            "author": "Ethan Mahintorabi",
            "discord": "ethanmoon",
            "title": "XorShift32",
            "description": "XorShift32 random number generator",
            "how_it_works": "Uses the Xorshift32 algorithm to generate a random 32 bit number. Number is truncated to 3 bits and displayed",
            "how_to_test": "While reset is set, hardware reads in seed value from input bits 2:7 and sets the inital seed as that binary number. After reset is deasserted, the hardware will generate a new number every 1000 clock cycles.",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "seed_bit0",
                "seed_bit1",
                "seed_bit2",
                "seed_bit3",
                "seed_bit4",
                "seed_bit5"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "counter.v",
                "decoder.v"
            ],
            "top_module": "xor_shift32_evango",
            "git_url": "https://github.com/QuantamHD/evan-submission"
        },
        "documentation": {
            "author": "Ethan Mahintorabi",
            "discord": "ethanmoon",
            "title": "XorShift32",
            "description": "XorShift32 random number generator",
            "how_it_works": "Uses the Xorshift32 algorithm to generate a random 32 bit number. Number is truncated to 3 bits and displayed",
            "how_to_test": "While reset is set, hardware reads in seed value from input bits 2:7 and sets the inital seed as that binary number. After reset is deasserted, the hardware will generate a new number every 1000 clock cycles.",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "seed_bit0",
                "seed_bit1",
                "seed_bit2",
                "seed_bit3",
                "seed_bit4",
                "seed_bit5"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "cells.v",
                "player.v",
                "flygoat_tune.v",
                "gm3hso_tune.v",
                "bh5hso_tune.v",
                "planetes_tune.v"
            ],
            "top_module": "flygoat_tt02_play_tune",
            "git_url": "https://github.com/FlyGoat/tt02-play-tune-flygoat"
        },
        "documentation": {
            "author": "Jiaxun Yang",
            "discord": "FlyGoat",
            "title": "Multiple Tunes on A Piezo Speaker",
            "description": "Plays multiple Tunes over a Piezo Speaker connected across io_out[1:0]",
            "how_it_works": "Converts an RTTL ringtone into verilog using Python - and plays it back using differential PWM modulation",
            "how_to_test": "Provide 10kHz clock on io_in[0], briefly hit reset io_in[1] (L->H->L) and io_out[1:0] will play a differential sound wave over piezo speaker, different tunes can be selected by different tune_sel inputs",
            "external_hw": "Piezo speaker connected across io_out[1:0]",
            "language": "verilog",
            "doc_link": "https://github.com/flygoat/tt02-play-tune-fg#readme",
            "clock_hz": 10000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "tune_sel0",
                "tune_sel1",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "piezo_speaker_p",
                "piezo_speaker_n",
                "ledout_0",
                "ledout_1",
                "ledout_2",
                "ledout_3",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "jleightcap_top.v",
                "top.v"
            ],
            "top_module": "jleightcap_top",
            "git_url": "https://github.com/mattvenn/clash-silicon-tinytapeout.git"
        },
        "documentation": {
            "author": "Jack Leightcap",
            "title": "clash cpu",
            "description": "tiny register machine written in clash",
            "how_it_works": "poorly",
            "how_to_test": "encode instructions. tick clock.",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "instr 5",
                "instr 4",
                "instr 3",
                "instr 2",
                "instr 1",
                "instr 0",
                "rst",
                "clock"
            ],
            "outputs": [
                "jump",
                "unused",
                "unused",
                "register 4",
                "register 3",
                "register 2",
                "register 1",
                "register 0"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "lcd.v",
                "toplevel.v"
            ],
            "top_module": "tt2_tholin_namebadge",
            "git_url": "https://github.com/89Mods/tt2-lcd-namebadge"
        },
        "documentation": {
            "discord": "Tholin#7559",
            "author": "Tholin",
            "title": "TinyTapeout 2 LCD Nametag",
            "description": "Echoes out a predefined text onto a 20x4 character LCD.",
            "how_it_works": "Mostly just contains a ROM holding the text to be printed, and some logic to print the reset sequence and cursor position changes.",
            "how_to_test": "Connect up a character LCD according to the pinout, set the clock and hit reset. Run using an extra slow clock, as there is no internal clock divider. It\u2019ll send data to the display as fast as it\u2019s able to. After that, it should initialize the display and start printing stuff. Also, connect LEDs to LED0 and LED1 if you want some blinkenlights.",
            "external_hw": "A 20x4 character LCD.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 100,
            "picture": "",
            "inputs": [
                "CLK",
                "RST",
                "EF0",
                "EF1",
                "EF2",
                "NC",
                "NC",
                "NC"
            ],
            "outputs": [
                "RS",
                "E",
                "D4",
                "D5",
                "D6",
                "D7",
                "LED0",
                "LED1"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347619669052490324",
            "git_url": "https://github.com/Christina-Cyr/tt02-submission-UART-CC"
        },
        "documentation": {
            "author": "Christina Cyr",
            "discord": "Christina-Cyr",
            "title": "UART-CC",
            "description": "UART Template",
            "how_it_works": "You can hook this up to an arduino",
            "how_to_test": "Use an arduino",
            "external_hw": "Arduino",
            "language": "wokwi",
            "doc_link": "https://github.com/Christina-Cyr/tt02-submission-UART-CC/blob/main/README.md",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "pwm.v"
            ],
            "top_module": "krasin_3_bit_8_channel_pwm_driver",
            "git_url": "https://github.com/krasin/tt02-verilog-3-bit-8-channel-pwm-driver"
        },
        "documentation": {
            "author": "Ivan Krasin",
            "discord": "krasin",
            "title": "3-bit 8-channel PWM driver",
            "description": "PWM driver with 8 channels and 8 PWM levels from 0 to 1",
            "how_it_works": "uses a 3-bit counter to drive PWM on 8 output channels. Each channel is controlled by a dedicated 3-bit register that specifies its PWM level: 0 means always off, 1 is for 1/7 on, 5 is for 5/7 on and 7 is 7/7 (always on)",
            "how_to_test": "after reset, all output pins will be low. Use set, addr<n> and level<n> pins to set PWM level=level0+2*level1+4*level2 on channel=addr0+2*addr1+4*addr2. The corresponding pin will start oscillating between 0 and 1 according to the clock and the set level.",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "pset",
                "addr0",
                "addr1",
                "addr2",
                "level0",
                "level1",
                "level2"
            ],
            "outputs": [
                "out0",
                "out1",
                "out2",
                "out3",
                "out4",
                "out5",
                "out6",
                "out7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "user_module_nickoe.v"
            ],
            "top_module": "user_module_nickoe",
            "git_url": "https://github.com/nickoe/tinytapeout02-verilog-gds-test"
        },
        "documentation": {
            "author": "Nick \u00d8stergaard",
            "discord": "nickoe#3016",
            "title": "LEDChaser from LiteX test",
            "description": "This is just a small demo of synthezing verilog from LiteX, this does not include any CPU.",
            "how_it_works": "It just implements LEDChaser from the LiteX LED core demo, where io_in[3:7] is duty cycle",
            "how_to_test": "Add LEDs on the outputs in a straight line -- or probe all signals on a scope and check that you get a 'moving' train of pulses.",
            "external_hw": "",
            "language": "LiteX/Migen/Verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "pwm_width 0",
                "pwm_width 1",
                "pwm_width 2",
                "pwm_width 3",
                "pwm_width 4",
                "pwm_width 5"
            ],
            "outputs": [
                "led a",
                "led b",
                "led c",
                "led d",
                "led e",
                "led f",
                "led g",
                "led h"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "fp8.v"
            ],
            "top_module": "cchan_fp8_multiplier",
            "git_url": "https://github.com/cchan/fp8_mul"
        },
        "documentation": {
            "author": "Clive Chan",
            "discord": "mrgoose#9005",
            "title": "8-bit (E4M3) Floating Point Multiplier",
            "description": "8-bit (E4M3) Floating Point Multiplier",
            "how_it_works": "A small mux in front to fill up two 8-bit buffers in halves, which feed the actual 8-bit multiplier.\nWhen ctrl0 is 0, you can clock in 4 bits from data[3:0] into the upper or lower halves of two buffers according to the values of ctrl[1] and ctrl[2]: - 00 STORE 1 LOWER - 01 STORE 1 UPPER - 10 STORE 2 LOWER - 11 STORE 2 UPPER The clock is intended for manual use instead of actually being driven by a clock, but it probably can work.\nThe 8 bits in each of the two buffers are interpreted as an 8-bit floating point number. From MSB to LSB: - sign bit - exponent[3:0] - mantissa[2:0] These are interpreted according to an approximation of IEEE 754, i.e.\n  (-1)**sign * 2**(exponent - EXP_BIAS) * 1.mantissa\nwith the following implementation details / differences: - EXP_BIAS = 7, analogous to 2**(exp-1) - 1 for all IEEE-defined formats - Denormals (i.e. exponent == 0) are flushed to zero on input and output - exponent = 0b1111 is interpreted as more normal numbers instead of NaN/inf,\n    and overflows saturate to the largest representable number (0bx1111111 = +/- 480.0)\n- Negative zero is interpreted as NaN instead. - Round to nearest even is implemented.\nThe output 8 bits will always display the results of the multiplication of the two FP8's in the buffers, regardless of the clock.\nThe module has been verified over all possible pairs of 8-bit inputs.\n",
            "how_to_test": "cd src && make\n",
            "external_hw": "",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "ctrl0",
                "ctrl1",
                "ctrl2",
                "data0",
                "data1",
                "data2",
                "data3"
            ],
            "outputs": [
                "sign",
                "exponent",
                "exponent",
                "exponent",
                "exponent",
                "mantissa",
                "mantissa",
                "mantissa"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "dice.v",
                "toplevel.v"
            ],
            "top_module": "tt2_tholin_diceroll",
            "git_url": "https://github.com/AvalonSemiconductors/tt2-diceroll"
        },
        "documentation": {
            "discord": "Tholin#7559",
            "author": "Tholin",
            "title": "Dice roll",
            "description": "Will roll a random number from 1 - 6 on the 7-segment display, like a dice.",
            "how_it_works": "Contains a LSFR for random numbers, that constantly updates no matter if the dice is rolling or not. Pressing the \u2019ROLL\u2019 button will play an animation of random numbers cycling on the display, until settling on a number after a few seconds. The decimal point will light up when its done rolling.",
            "how_to_test": "Reset, then pulse \u2019ROLL\u2019 to roll the dice as many time as you like.",
            "external_hw": "A 7-segment-display. The one on-board the PCB will work.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 6000,
            "picture": "",
            "inputs": [
                "CLK",
                "RST",
                "ROLL",
                "NC",
                "NC",
                "NC",
                "NC",
                "NC"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "decimal point"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349901899339661908",
            "git_url": "https://github.com/NYIT-CNS/cns001-tt02-submission1"
        },
        "documentation": {
            "author": "Bryan Bonilla Garay, Devin Alvarez, Ishaan Singh, Yu Feng Zhou, and N. Sertac Artan",
            "discord": "sertacartan#9663",
            "title": "CNS TT02 Test 1:Score Board",
            "description": "First test run of CNS Lab. Displays an 8-bit score from one of two players as a two-digit hexadecimal value.",
            "how_it_works": "Two counters keep track of user scores, which can be updated, and displayed on the 7-segment display.",
            "how_to_test": "Wokvi",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "https://github.com/arta-ns/tt02-cns-submission/blob/main/README.md",
            "clock_hz": 0,
            "picture": "https://github.com/NYIT-CNS/cns001-tt02-submission1/blob/main/score-board.png",
            "inputs": [
                "clock",
                "reset",
                "none",
                "rst",
                "display_digit",
                "display_user",
                "user",
                "mode"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "dot"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349953952950780498",
            "git_url": "https://github.com/NYIT-CNS/cns002-tt02-submission2"
        },
        "documentation": {
            "author": "Bryan Bonilla Garay, Devin Alvarez, Ishaan Singh, Yu Feng Zhou, and N. Sertac Artan",
            "discord": "sertacartan#9663",
            "title": "CNS002 (TT02-Test 2)",
            "description": "First test run of CNS Lab (second design)",
            "how_it_works": "Apply inputs, get outputs",
            "how_to_test": "Wokvi",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "https://github.com/arta-ns/tt02-cns-submission/blob/main/README.md",
            "clock_hz": 0,
            "picture": "https://github.com/mole99/wokwi-1bit-alu/raw/main/img/1bit-alu.png",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "348540666182107731",
            "git_url": "https://github.com/shaos/tt02-submission-shaos"
        },
        "documentation": {
            "author": "Shaos",
            "discord": "Shaos#3571",
            "title": "Test2",
            "description": "Testing Flip-Flops",
            "how_it_works": "nothing special - just testing",
            "how_to_test": "change inputs and see outputs :)",
            "external_hw": "logic analyzer",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "wokwi-sch-1.png",
            "inputs": [
                "clock",
                "D",
                "C",
                "S",
                "R",
                "NAND1",
                "NAND2",
                "Muller"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "dot"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341490465660469844",
            "git_url": "https://github.com/toybuilder/tt02-learn-tinytapeout"
        },
        "documentation": {
            "author": "Joseph Chiu",
            "discord": "toybuilder#2690",
            "title": "7-segment LED flasher",
            "description": "Drives 7-segment LED display, alternating between NIC and JAC",
            "how_it_works": "Master clock is fed through a prescaler with four tap-points which feeds a 4-bit ripple counter (there are 6 total bits, but the top two bits are discarded). 2:1 muxes are chained to act like a 8:1 mux for each LED segment position. As the counter runs, this results in each segment being turned on or off as needed to render the display sequence (NIC JAC ).  The highest order bit is used to blink the decimal point on/off. ",
            "how_to_test": "IN5 and IN6 selects the clock prescaler. OUT0-OUT7 are the LED segment outputs.",
            "external_hw": "TTO standard switches and 7-segment display",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "Prescale select bit 0",
                "Prescale select bit 1",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment dp"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349047610915422802",
            "git_url": "https://github.com/drburke3/tt02-nano-neuron"
        },
        "documentation": {
            "author": "Daniel Burke",
            "discord": "GoldfishGuy#5692",
            "title": "Nano-neuron",
            "description": "minimal low vector test",
            "how_it_works": "bare influence field calculation GV open neurons",
            "how_to_test": "clock in reference vector (some inversions), present DUT and get outupt",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "cells.v",
                "sqrt.v"
            ],
            "top_module": "udxs_sqrt_top",
            "git_url": "https://github.com/UDXS/sqrt-tt02"
        },
        "documentation": {
            "author": "Davit Margarian (UDXS)",
            "discord": "UDXS#2531",
            "title": "SQRT1 Square Root Engine",
            "description": "Computes 4.2 fixed-point square root for any 7-bit integer",
            "how_it_works": "This uses Newton's method to solve sqrt in 3 cycles.",
            "how_to_test": "Set a 7-bit input value and toggle clock 3 times. After, the output will be correct, rounded down to the nearest 4th.",
            "external_hw": "Optionally, binary to BCD converter for output",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "i1",
                "i2",
                "i3",
                "i4",
                "i5",
                "i6",
                "i7"
            ],
            "outputs": [
                "frac1",
                "frac2",
                "whole1",
                "whole2",
                "whole3",
                "whole4",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "pwm_gen.v"
            ],
            "top_module": "pwm_gen",
            "git_url": "https://github.com/argunda/tt02-breathing-led"
        },
        "documentation": {
            "author": "argunda",
            "discord": "catbeans",
            "title": "Breathing LED",
            "description": "Use the pwm output to drive an LED and it should look like it's breathing.",
            "how_it_works": "A triangle wave is generated and used to determine duty cycle of pwm.",
            "how_to_test": "After reset, pwm should automatically be generated. The duty counter is output for debug purposes.",
            "external_hw": "Clock source and external LED circuit.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 4000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "breathing_pwm",
                "duty[0]",
                "duty[1]",
                "duty[2]",
                "duty[3]",
                "duty[4]",
                "duty[5]",
                "duty[6]"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "user_module_341164910646919762.v"
            ],
            "top_module": "user_module_341164910646919762",
            "git_url": "https://github.com/daniestevez/tt02-gold-fibonacci"
        },
        "documentation": {
            "author": "Daniel Estevez",
            "discord": "destevez#8268",
            "title": "Fibonacci & Gold Code",
            "description": "This project includes two independent designs: a design that calculates terms of the Fibonacci sequence and displays them in hex one character at a time on a 7-segment display, and a Gold code generator that generates the codes used by CCSDS X-band PN Delta-DOR.",
            "how_it_works": "The Fibonacci calculator uses 56-bit integers, so the terms of the Fibonacci sequence are displayed using 7 hex characters. Since the TinyTapeout PCB only has one 7-segment display, the terms of the Fibonacci sequence are displayed one hex character at a time, in LSB order. The dot of the 7-segment display lights up whenever the LSB is being displayed. On each clock cycle, 4-bits of the next Fibonacci term are calculated using a 4-bit adder, and 4-bits of the current term are displayed in the 7-segment display. The 7-segment display is ANDed with the project clock, so that the digits flash on the display.\nThe Gold code generator computes a CCSDS X-band PN Delta-DOR Gold code one bit at a time using LFSRs. The output bit is shown on the 7-segment display dot. 6-bits of the second LFSR can be loaded in parallel using 6 project inputs in order to be able to generate different sequences. One of the project inputs is used to select whether the 7-segment display dot is driven by the Fibonacci calculator or by the Gold code generator.",
            "how_to_test": "The project can be tested by manually driving the clock using a push button or switch. Just by de-asserting the reset and driving the clock, the digits of the Fibonacci sequence terms should appear on the 7-segment display. The output select input needs to be set to Gold code (high level) in order to test the gold code generator. The load enable input (active-low), as well as the 6 inputs corresponding to the load for the B register can be used to select the sequence to generate. The load value can be set in the 6 load inputs, and then the load enable should be pulsed to perform the load. This can be done with the clock running or stopped, as the load enable is asynchronous. After the load enable is de-asserted, for each clock cycle a new bit of the Gold code sequence should appear in the 7-segment display dot.",
            "external_hw": "No external hardware is needed",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "output select (high selects Gold code; low selects Fibonacci LSB marker) & Gold code load value bit 0",
                "Fibonacci reset (active-low; asynchronous) & Gold code load value bit 1",
                "Gold code load enable (active-low; asynchronous)",
                "Gold code load value bit 2",
                "Gold code load value bit 3",
                "Gold code load value bit 4",
                "Gold code load value bit 5"
            ],
            "outputs": [
                {
                    "segment a": "Fibonacci hex digit"
                },
                {
                    "segment b": "Fibonacci hex digit"
                },
                {
                    "segment c": "Fibonacci hex digit"
                },
                {
                    "segment d": "Fibonacci hex digit"
                },
                {
                    "segment e": "Fibonacci hex digit"
                },
                {
                    "segment f": "Fibonacci hex digit"
                },
                {
                    "segment g": "Fibonacci hex digit"
                },
                {
                    "none": "Gold code output / Fibonacci LSB digit marker"
                }
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341609034095264340",
            "git_url": "https://github.com/r4d10n/tt02-HELLo-3orLd-7seg"
        },
        "documentation": {
            "author": "Rakesh Peter",
            "discord": "r4d10n#3258",
            "title": "tinytapeout2-HELLo-3orLd-7seg",
            "description": "HELLo-3orLd Runner on 7 segment Display",
            "how_it_works": "BCD to 7seg Counter is modified to suit the Simplified SoP equation for each segments. See the repo for SoP computation.",
            "how_to_test": "All toggle switches in zero position and clock switch on for auto runner. Individual BCD bits can be toggled using corresponding inputs with clock switch off.",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "https://github.com/r4d10n/tinytapeout-HELLo-3orLd-7seg/blob/main/README.md",
            "clock_hz": 1,
            "picture": "HELLo-3orld-7seg.png",
            "inputs": [
                "clock",
                "reset",
                "none",
                "dp toggle",
                "BCD bit 3",
                "BCD bit 2",
                "BCD bit 1",
                "BCD bit 0"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment dp"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "navray_top.sv",
                "sqrt.sv",
                "seg7.sv"
            ],
            "top_module": "navray_top",
            "git_url": "https://github.com/navray/tt02-square-root"
        },
        "documentation": {
            "author": "Wallace Everest",
            "discord": "morningjava#9314",
            "title": "Non-restoring Square Root",
            "description": "Square root for use in RMS calculations",
            "how_it_works": "7-bit input, 4-bit output, unsigned",
            "how_to_test": "Apply unsigned input {0x0..0x7F} to the logic pins",
            "external_hw": "Result on 7-segment display {0x0..0xB}",
            "language": "SystemVerilog",
            "doc_link": "https://github.com/navray/tt02-square-root/blob/main/README.md",
            "clock_hz": 1000,
            "picture": "./pics/gravity_well.png",
            "inputs": [
                "clk",
                "data(0)",
                "data(1)",
                "data(2)",
                "data(3)",
                "data(4)",
                "data(5)",
                "data(6)"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment dp"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349011320806310484",
            "git_url": "https://github.com/shaos-net/tt02-submission-shaos2"
        },
        "documentation": {
            "author": "Shaos",
            "discord": "Shaos#3571",
            "title": "GOL-Cell",
            "description": "Game of Life Cell",
            "how_it_works": "Calculate survive/die decision based on number of neighbours and current state",
            "how_to_test": "Change number of neighbours and see",
            "external_hw": "8 neighbours and rerouted current state need to go in 2 stages using 5 inputs",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "wokwi-sch.png",
            "inputs": [
                "clock",
                "reset",
                "half",
                "input 0 or 5",
                "input 1 or 6",
                "input 2 or 7",
                "input 3 or 8",
                "input 4 or 9"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "inverted clock"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "pwm.v"
            ],
            "top_module": "krasin_tt02_verilog_spi_7_channel_pwm_driver",
            "git_url": "https://github.com/krasin/tt02-verilog-spi-7-channel-pwm-driver"
        },
        "documentation": {
            "author": "Ivan Krasin",
            "discord": "krasin",
            "title": "7-channel PWM driver controlled via SPI bus",
            "description": "PWM driver with 7 channels and 256 PWM levels from 0 to 1",
            "how_it_works": "uses a 8-bit counter to drive PWM on 7 output channels. Each channel is controlled by a dedicated 8-bit register that specifies its PWM level: 0 means always off, 1 is for 1/255 on, 5 is for 5/255 on and 255 is 255/255 (always on)",
            "how_to_test": "after reset, all output pins will be low. Use SPI writes with register addresses (0..6) to set 8-bit PWM levels. The corresponding pin will start oscillating between 0 and 1 according to the clock and the set level.",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "cs",
                "sclk",
                "mosi",
                "reserved",
                "reserved",
                "reserved"
            ],
            "outputs": [
                "out0",
                "out1",
                "out2",
                "out3",
                "out4",
                "out5",
                "out6",
                "miso"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "hex_sr.v",
                "sr_recirc.v"
            ],
            "top_module": "hex_sr",
            "git_url": "https://github.com/brouhaha/tt02-hex-sr"
        },
        "documentation": {
            "author": "Eric Smith",
            "discord": "brouhaha",
            "title": "hex shift register",
            "description": "six 40-bit shift registers",
            "how_it_works": "Six 40-bit shift registers. A multiplexer selects input data or recirulating output data.",
            "how_to_test": "on each clock n, six bits are shifted in, and the six bits that were input at clock n-4 are output",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "https://github.com/brouhaha/tt02-hex-sr/blob/main/README.md",
            "clock_hz": "",
            "picture": "",
            "inputs": [
                "clk",
                "recirc",
                "data_in[0]",
                "data_in[1]",
                "data_in[2]",
                "data_in[3]",
                "data_in[4]",
                "data_in[5]"
            ],
            "outputs": [
                "none",
                "none",
                "data_out[0]",
                "data_out[1]",
                "data_out[2]",
                "data_out[3]",
                "data_out[4]",
                "data_out[5]"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "speed_test.v"
            ],
            "top_module": "ericsmi_speed_test",
            "git_url": "https://github.com/ericsmi/tt02-verilog-ring-osc-demo"
        },
        "documentation": {
            "author": "Eric Smith",
            "discord": "Eric Smith",
            "title": "Ring OSC Speed Test",
            "description": "Make two rings with the same number of stages but measure how their frequency differs.  Measure if they can influence eachother.",
            "how_it_works": "uses a register and some combinational logic",
            "how_to_test": "after reset, assert trigger.  Use sel bits to get result",
            "external_hw": "Something to sequence nrst, ring_en, trig and the sel bits",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 6000,
            "picture": "pic/tt_speed_test.pdf",
            "inputs": [
                "clock",
                "nreset",
                "trig",
                "sel[0]",
                "sel[1]",
                "sel[2]",
                "ring_en[0]",
                "ring_en[1]"
            ],
            "outputs": [
                "out[0]",
                "out[1]",
                "out[2]",
                "out[3]",
                "out[4]",
                "out[5]",
                "out[6]",
                "out[7]"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "tt2.v",
                "pid.v",
                "spi_master_in.v",
                "spi_master_out.v",
                "spi_slave.v"
            ],
            "top_module": "AidanMedcalf_pid_controller",
            "git_url": "https://github.com/AidanMedcalf/tt02-pid"
        },
        "documentation": {
            "author": "Aidan Medcalf",
            "discord": "Pomme de Terrible#1820",
            "title": "TinyPID",
            "description": "Tiny PID controller with SPI configuration channel, SPI ADC and DAC driver",
            "how_it_works": "TinyPID reads from a shift register, calculates error and PID values, and writes to a shift register. All parameters of this process are configurable.",
            "how_to_test": "Shift in config, then shift in PV input and see what happens. There are three bytes of configuration (setpoint, kp, ki), which are zero on startup.",
            "external_hw": "One shift register / ADC for PV read, one shift register / DAC for stimulus output.",
            "language": "Verilog",
            "doc_link": "https://github.com/AidanMedcalf/tt02-pid/blob/main/README.md",
            "clock_hz": 1,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "cfg_clk",
                "cfg_mosi",
                "none",
                "cfg_cs",
                "pv_in_miso"
            ],
            "outputs": [
                "pv_in_clk",
                "pv_in_cs",
                "out_clk",
                "out_mosi",
                "out_cs",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "TrainLED2_top.v",
                "TrainLED2.v"
            ],
            "top_module": "cpldcpu_TrainLED2top",
            "git_url": "https://github.com/cpldcpu/tt02-TrainLED"
        },
        "documentation": {
            "author": "cpldcpu",
            "discord": "Azure#5593",
            "title": "TrainLED2 - RGB-LED driver with 8 bit PWM engine",
            "description": "A RGB-LED driver using the WS2812 protocol",
            "how_it_works": "A fully digital implementation of an RGB LED driver that accepts the WS2812 protocol for data input. The design is fully clocked, so the timing parameters of the protocol depend on the clock rate. A pulse between 1 and 5 clock cycles on the input will be interpreted as a zero, longer pulses as a one. Each driver accepts 3x8=24 bit of input data to set the brightness of LED1,LED2 and LED3 (R,G,B). After 24 bit have been received, additional input bits are retimed and forwarded to the data output.\nAfter the data input was idle for 96 clock cycles, the input data is latched into the PWM engine and the data input is ready for the next data frame.\nThe PWM engine uses a special dithering scheme to allow flicker free LED dimming even for relatively low clock rates. ",
            "how_to_test": "Execute the shell script 'run.sh' in the src folder. This will invoke the test bench.",
            "external_hw": "LEDs should be connected to the three LED outputs. The data input should be driven by a microcontroller, generating input data in a slowed down WS2812 scheme.",
            "language": "Verilog",
            "doc_link": "https://github.com/cpldcpu/tt02-TrainLED",
            "clock_hz": "at least 6000",
            "picture": "tb_screenshot.png",
            "inputs": [
                "clock",
                "reset",
                "Din Driver A",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "Dout Driver A",
                "LED1A",
                "LED2A",
                "LED3A",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "mcpu5plus.v"
            ],
            "top_module": "cpldcpu_MCPU5plus",
            "git_url": "https://github.com/cpldcpu/tt02-mcpu5plus"
        },
        "documentation": {
            "author": "cpldcpu",
            "discord": "Azure#5593",
            "title": "Zinnia+ (MCPU5+) 8 Bit CPU",
            "description": "A minimal 8 bit CPU",
            "how_it_works": "The CPU is based on the Harvard Architecture with separate data and program memories. The data memory is completely internal to the CPU. The program memory is external and is accessed through the I/O. All data has to be loaded as constants through machine code instructions.\nTwo of the input pins are used for clock and reset, the remaining ones are used as program input, allowing for an instruction length of 6 bit. The output is multiplexed between the program counter (when clk is '1') and the content of the main register, the Accumulator. Interpreting the accumulator content allows reading the program output.",
            "how_to_test": "Execute the shell script 'run.sh primes' in the src folder. This will invoke the testbench with a rom emulator and execute a small program to compute prime numbers.",
            "external_hw": "External program memory and bus demultiplexer is required.",
            "language": "verilog",
            "doc_link": "https://github.com/cpldcpu/tt02-mcpu5plus",
            "clock_hz": "high",
            "picture": "https://user-images.githubusercontent.com/4086406/203659032-e13c530f-e562-4d85-aa3f-09143ee01ffc.png",
            "inputs": [
                "clock",
                "reset",
                "inst_in[0]",
                "inst_in[1]",
                "inst_in[2]",
                "inst_in[3]",
                "inst_in[4]",
                "inst_in[5]"
            ],
            "outputs": [
                "cpu_out[0]",
                "cpu_out[1]",
                "cpu_out[2]",
                "cpu_out[3]",
                "cpu_out[4]",
                "cpu_out[5]",
                "cpu_out[6]",
                "cpu_out[7]"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "cpu.v"
            ],
            "top_module": "moonbase_cpu_4bit",
            "git_url": "https://github.com/MoonbaseOtago/tt-cpu"
        },
        "documentation": {
            "author": "Paul Campell",
            "discord": "Taniwha",
            "title": "4 bit CPU",
            "description": "simple cpu",
            "how_it_works": " It has a 4-bit accumulator, a 7-bit PC, 2 7-bit index registers and a carry bit.\nThe main limitations are the 6/8-bit bus - it's designed to run with an external SRAM and a 7-bit address latch, code is loaded externally.\nThere are 25 instructions. each 2 or 3 nibbles:\n- 0 V:\t add a, V(x/y)\t- sets C - 1 V: \t sub a, V(x/y)\t- sets C - 2 V:\t or a, V(x/y) - 3 V:\t and a, V(x/y) - 4 V:\t xor a, V(x/y) - 5 V:\t mov a, V(x/y) - 6 V:\t movd a, V(x/y) - 7 0:\t swap x, y - 7 1:   add a, c - 7 2:   mov x.l, a - 7 3:   ret - 7 4:   add y, a - 7 5:   add x, a - 7 6:   add y, #1 - 7 6:   add x, #1 - 8 V:\t mov a, #V - 9 V:\t add a, #V - a V:\t movd V(x/y), a - b V: \t mov  V(x/y), a - c H L: mov x, #hl - d H L: jne a/c, hl\tif H[3] the test c otherwise test a - e H L: jeq a/c, hl\tif H[3] the test c otherwise test a - f H L: jmp/call hl    if H[3] call else jmp\nMemory is 128/256 (128 unified or 128xcode+128xdata) 4-bit nibbles, references are a 3 bit (8 nibble) offset from the X or Y index registers - the general idea is that the Y register points to an 8 register scratch pad block (a bit like an 8051) but can also be repurposed for copies when required. There is an on-chip SRAM block for data access only (addressed with the MSB of the data address) - mostly just to soak up any additional gates.\nThere is also a 4-deep hardware call stack.\n",
            "how_to_test": "needs a 7-bit external address latch and SRAM",
            "external_hw": "sram, latch",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": " ",
            "inputs": [
                "clock",
                "reset",
                "ram_data0",
                "ram_data1",
                "ram_data2",
                "ram_data3",
                "io_data0",
                "io_data1"
            ],
            "outputs": [
                "data_out_0",
                "data_out_1",
                "data_out_2",
                "data_out_3",
                "write_data_n",
                "write_ram_n",
                "a",
                "strobe"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "top.v",
                "decoder.v",
                "shift_register.v",
                "stack_register.v",
                "stack_cpu.v",
                "input_selector.v",
                "output_multiplexer.v",
                "memory.v"
            ],
            "top_module": "davidsiaw_stackcalc",
            "git_url": "https://github.com/davidsiaw/tt02-davidsiaw-stackcalc"
        },
        "documentation": {
            "author": "David Siaw",
            "discord": "astrobunny#7777",
            "title": "Stack Calculator",
            "description": "A stack based 4-bit calculator featuring a 4-bit wide 8 entry deep stack and 64 bits of random access memory.",
            "how_it_works": "The stack calculator is a 4-bit calculator. It is meant to be used in a\nlarger circuit that will handle timing and memory. It is not a processor\nsince it does not contain a program counter or attempt to access memory\non its own. Rather, it accepts inputs in particular sequences and gives\noutputs depending on the instructions provided.\n\nThe stack calculator consists of a 4-bit wide stack that is 8 entries deep.\nThe thing that makes it a stack calculator is the fact that all operations\nare performed against this stack. The user will provide opcodes at every\nupwards tick of the clock cycle to instruct the machine on what to do next.\n\nThe stack calculator can also save 16 4-bit values using the `SAVE` and `LOAD`\noperations.\n\nAll opcodes are 4 bits long. Some opcodes accept one additional input that\ndefine the operation. Ops take at least 2 cycles to complete and at most\n5 cycles.\n\nOpcodes and operands are always 4-bits wide and are applied to the 4 input\npins (pins 2-5) and need to be applied before the clock ticks up. In some\ncases they need to be held for more than one cycle for them to apply.\n\nAll input must be provided in a particular order. Below is a timing diagram\nthat shows how to apply opcodes to the processor\n\n```\nTiming diagram\n\nCLK   ___     ___     ___     ___     ___     ___\n   __/   \\___/   \\___/   \\___/   \\___/   \\___/   \\___\n     |       |       |       |       |       |\n     |       |       |       |       |       |\n1.   ___________     ________________________________\n   _/  OP CODE  \\___/ next operation ...\n\n2.   _____________  _____________    ________________\n   _/   OP CODE   \\/   OPERAND   \\__/ next op...\n\n3.   _____________  _____________            ________\n   _/   OP CODE   \\/   OPERAND   \\__________/ ...\n                                 wait 1 cycle\n\nLEGEND\n1. 2-cycle opcode, no operands\n2. 4-cycle opcode, 1 operand\n3. 5-cycle opcode, 1 operand (PUSH)\n\n```\n\nThe stack machine also features an output register that can be written to using the\n`OUTL` and `OUTH` operations.\n\nRESET PIN - Please hold the reset pin high and tick the clock at least 4 cycles to\nreset the machine.\n\nMODE PINS - The input pins 6 and 7 are the mode pin. They can be used to set the output\npins to output specific things depending on their value:\n\n- 00 - show contents of the output register\n- 01 - show 7-segment display of the top of the stack\n- 10 - show 7-segment display of the value just beneath the top of the stack\n- 11 - show the top 2 values on the stack on the low and high nibbles respectively.\n\nThe list opcodes are as follows:\n\n- 0x1 PUSH\n  - Pushes a value to the stack. The value must be provided in the following cycle.\n  - 5 cycles - push, push, value, value, wait\n- 0x2 POP\n  - Pops a value from the stack. The value must be provided in the following cycle.\n  - 3 cycles - pop, pop, wait\n- 0x3 OUTL\n  - Copies the value on the top of the stack to the lower 4 bits of the output register.\n  - 2 cycles - outl, outl\n- 0x4 OUTH\n  - Copies the value on the top of the stack to the high 4 bits of the output register.\n  - 2 cycles - outh, outh\n- 0x5 SWAP\n  - Swaps the top two values on the stack.\n  - 3 cycles - swap, swap, wait\n- 0x6 PUSF\n  - Push a value on the stack depending on the operand. The operand determines the values pushed on the stack.\n  - 4 cycles - peek/dupl/flag, =, wait\n    - 0x0 DUPL - pushes a copy of the value on the top of the stack to the top of the stack\n    - 0x1 PEEK - pushes a copy of the value below the top of the stack to the top of the stack\n    - 0x2 FLAG - pushes the contents of the status register\n- 0x7 REPL\n  - Removes the value at the top of the stack and pushes the value modified by an unary operation\n  - 4 cycles - not/neg/incr/decr/shr1/shr2/ror1/rol1, =, wait\n    - 0x0 NOT  - bitwise NOT\n    - 0x1 NEG  - negative, or 2's complement\n    - 0x2 INCR - increment\n    - 0x3 DECR - decrement\n    - 0x4 SHR1 - shift right by 1\n    - 0x5 SHL1 - shift left by 1\n    - 0x6 ROR1 - rotate right by 1\n    - 0x7 ROL1 - rotate left by 1\n- 0x8 BINA\n  - Binary operation - removes the top two values of the stack and pushes the result of a binary operation\n  - 4 cycles - add/and/not/xor/addc/mull/mulh, wait, wait\n    - 0x0 ADD  - add (will set the status register carry flag if result > 15)\n    - 0x1 AND  - bitwise AND\n    - 0x2 OR  - bitwise OR\n    - 0x3 XOR  - bitwise XOR\n    - 0x4 ADDC - add with carry. same as add but +1 if carry flag is set\n    - 0x5 MULL - low nibble from result of multiplication\n    - 0x6 MULH - high nibble from result of multiplication\n- 0x9 MULT\n  - Full multiply of the top two nibbles on the stack. Pushes the high nibble and then the low nibble to the stack in that order.\n  - 4 cycles - mult, mult, wait, wait\n- 0xA IDIV\n  - Divide the value below the top of the stack by the value on the top of the stack. Pushes the remainder and the integer division result in order.\n  - 4 cycles - idiv, idiv, wait, wait\n- 0xB CLFL\n  - Unset all flags in flag register\n  - 4 cycles - clfl, clfl\n- 0xC SAVE\n  - Writes the value below the top of the stack to the address provided at the top of the stack.\n  - 4 cycles - save, save, wait, wait\n- 0xD LOAD\n  - Loads the value at the address provided at the top of the stack.\n  - 4 cycles - load, load, wait, wait\n",
            "how_to_test": "The following diagram shows a simple test setup that can be used to test\nthe stack calculator\n\n```\n  VCC\n  |    __|__ pushbutton\n  +----.   .-------------+\n  |                     _|_\n  |          schmitt    \\ /\n  |          trigger     O\n  |          inverter    |\n  |  __|__               +--> CLK  OUT0 -----+\n  +--.   .------------------> RST  OUT1 -.   |\n    button     +--------+---> IN0    .      _|_\n               +        +---> IN1    .      \\ / buffer\n               +        +---> IN2    .       |\n               +  DIP   +---> IN3            |\n               + switch +---> MODE0          +--> 7 segment\n               +        +---> MODE1          |\n               +        +--                  +--> LED bar array\n               +--------+--\n                                              .\n                                              .\n                                              .\n```\n\nBy using a schmitt trigger for debounce and an inverter, it is possible\nto perform a tick up with a specific DIP switch setting, allowing us\nto experiment with different kinds of inputs in sequence.\n\nUsing the DIP switch you can also change the MODE pins to debug your\nstack or display the output register contents.\n",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "doc/stackcalc.png",
            "inputs": [
                "clk",
                "rst",
                "input0",
                "input1",
                "input2",
                "input3",
                "mode0",
                "mode1"
            ],
            "outputs": [
                "output0",
                "output1",
                "output2",
                "output3",
                "output4",
                "output5",
                "output6",
                "output7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "340318610245288530",
            "git_url": "https://github.com/mole99/tt02-1bit-alu"
        },
        "documentation": {
            "author": "Leo Moser",
            "discord": "",
            "title": "1-bit ALU",
            "description": "1-bit ALU from the book `Structured Computer Organization: Andrew S. Tanenbaum`",
            "how_it_works": "The 1-bit ALU implements 4 different operations: AND, NOT, OR, ADD.\nThe current operating mode can be selected via F0 and F1. F0=0 and F1=0 results in A AND B. F0=1 and F1=0 results in NOT B. F0=0 and F1=1 results in A OR B. F0=1 and F1=1 results in A ADD B. Where A and B are the inputs for the operation.\nAdditional inputs can change the way of operation:\n`ENA` and `ENB` enable/disable the respective input. `INVA` inverts A before applying the operation. `CIN` is used as input for the full adder.\nMultiple 1bit ALUs could be chained to create a wider ALU. ",
            "how_to_test": "Set the operating mode via the DIP switches with F0 and F1.\nNext, set the input with A and B and enable both signals with ENA=1 and ENB=1. If you choose to invert A, set INVA to 1, otherwise to 0. For F0=1 and F1=1 you can set CIN as additional input for the ADD operation.\nThe 7-segment display shows either a `0` or a `1` depending on the output. If the ADD operation is selected, the dot of the 7-segment display represents the COUT. ",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "https://github.com/mole99/tt02-1bit-alu/blob/main/README.md",
            "clock_hz": 0,
            "picture": "img/1bit-alu.png",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "COUT"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349228308755382868",
            "git_url": "https://github.com/steieio/tt02-sfsm-wokwi"
        },
        "documentation": {
            "author": "Greg Steiert",
            "discord": "gsteiert #6753",
            "title": "SPI Flash State Machine",
            "description": "Implements a state machine stored in an external SPI flash",
            "how_it_works": "Inputs and current state are shifted into a SPI flash to look up the next state and outputs",
            "how_to_test": "Connect a SPI flash device loaded with state machine values",
            "external_hw": "SPI Flash with 0x03 read command and 24bit address",
            "language": "wokwi",
            "doc_link": "https://github.com/steieio/tt02-sfsm-wokwi/blob/main/README.md",
            "clock_hz": 0,
            "picture": "sfsm.png",
            "inputs": [
                "clock",
                "reset",
                "din",
                "in0",
                "in1",
                "in2",
                "in3",
                "in4"
            ],
            "outputs": [
                "cs",
                "dout",
                "out0",
                "out1",
                "out2",
                "out3",
                "out4",
                "out5"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341571228858843732",
            "git_url": "https://github.com/youngpines/tt02-youngpines-submission"
        },
        "documentation": {
            "author": "youngpines",
            "discord": "youngpines#5259",
            "title": "r2rdac",
            "description": "small r2r",
            "how_it_works": "add a resistor ladder on the d flip flop outputs and you get a dac. AND gate is removed, pin2 is a passthrough",
            "how_to_test": "attach a r2r ladder and a non-inverting op-amp on the output and you can control the adc output",
            "external_hw": "resistors, opamp, and you",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "348381622440034899",
            "git_url": "https://github.com/timvgso/tinatapeworm"
        },
        "documentation": {
            "author": "Tim Victor",
            "discord": "",
            "title": "Worm in a Maze",
            "description": "Animation demo on seven-segment LED",
            "how_it_works": "A segmented worm travels along a pseudo-random path",
            "how_to_test": "Maximum clock divider will probably be best",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 25,
            "picture": "",
            "inputs": [
                "clock",
                "disable auto-reset",
                "manual reset",
                "disable /16 clock divider (\"turbo mode\")",
                "display 2 or 3 worm segments",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "LED segment a",
                "LED segment b",
                "LED segment c",
                "LED segment d",
                "LED segment e",
                "LED segment f",
                "LED segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "cpu.v"
            ],
            "top_module": "moonbase_cpu_8bit",
            "git_url": "https://github.com/OneRNG/tt-cpu8"
        },
        "documentation": {
            "author": "Paul Campell",
            "discord": "Taniwha",
            "title": "8 bit CPU",
            "description": "8-bit version of the MoonBase 4-bit CPU",
            "how_it_works": " It has an 8-bit accumulator, a 12-bit PC, 2 13-bit index registers and a carry bit.\nThe main limitations are the 6/8-bit external bus - it's designed to run with an external SRAM and a 12-bit address latch, code is loaded externally.\nThere are 33 instructions. each 1, 2 or 3 bytes:\n0v:         add a, v(x/y)   - sets C 1v:         sub a, v(x/y)   - sets C 2v:         or a, v(x/y) 3v:         and a, v(x/y) 4v:         xor a, v(x/y) 5v:         mov a, v(x/y) 6v:         movd a, v(x/y) 70:         add a, c 71:         inc a 72:         swap x, y 73:         ret 74:         add y, a 75:         add x, a 76:         add y, #1 77:         add x, #1 78:         mov a, y 79:         mov a, x 7a:         mov b, a 7b:         swap b, a 7c:         mov y, a 7d:         mov x, a 7e:         clr a 7f:         mov a, p 8v:         nop 9v:         nop av:         movd v(x/y), a bv:         mov  v(x/y), a cv:         nop dv:         nop ev:         nop f0 HL:      mov a, #HL f1 HL:      add a, #HL f2 HL:      mov y, #EEHL f3 HL:      mov x, #EEHL f4 HL:      jne a/c, EEHL     if EE[4] the test c otherwise test a f5 HL:      jeq a/c, EEHL     if EE[4] the test c otherwise test a f6 HL:      jmp/call EEHL f7 HL:      nop\nMemory is 4096 8-bit bytes, references are a 3 bit (8 byte) offset from the X or Y index registers - the general idea is that the Y register points to a register scratch pad block (a bit like an 8051) but can also be repurposed for copies when required. There is an on-chip SRAM block for data access only (addressed with the MSB of the data address) - mostly just to soak up any additional gates.\nThere is also a 3-deep hardware call stack.\nAssembler is here: https://github.com/MoonbaseOtago/tt-asm ",
            "how_to_test": "needs a 7-bit external address latch and SRAM",
            "external_hw": "sram, latch",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": " ",
            "inputs": [
                "clock",
                "reset",
                "ram_data0",
                "ram_data1",
                "ram_data2",
                "ram_data3",
                "io_data0",
                "io_data1"
            ],
            "outputs": [
                "data_out_0",
                "data_out_1",
                "data_out_2",
                "data_out_3",
                "write_data_n",
                "write_ram_n",
                "a",
                "strobe"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341178154799333971",
            "git_url": "https://github.com/tcptomato/tt02-submission-template"
        },
        "documentation": {
            "author": "Thomas B\u00f6hm <thomas.bohm@gmail.com>",
            "discord": "",
            "title": "Pseudo-random number generator",
            "description": "Pseudo-random number generator using a 16-bit Fibonacci linear-feedback shift register",
            "how_it_works": "16 flip flops are connected in a chain, and the output of some is XORed together and fed back into the first flip flop. The outputs that are XORed together are chosen in such a way as to give the longest possible cycle (2^16-1). All bits being zero is a special case and is treated separately (all negative outputs of the flip flops are ANDed together to generate a 1 as feedback).\nOn each clock pulse (pin 1) one new bit is generated. Setting load_en (pin 3) to HIGH allows the loading of a user defined value through the data_in pin (pin2). On each clock pulse one bit is read into the flip flop chain. When load_en (pin 3) is set to LOW the computed feedback bit is fed back into the flip flops.\nThe outputs of the last 8 flip flops are connected to the output pins. For each clock pulse a random bit is generated and the other 7 are shifted. ",
            "how_to_test": "Set the switch for pin 1 so that the push button generates the clock. Press on it and see the output change on the hex display.\nUsing pin 2 and 3 a custom value can be loaded into the flip flops. ",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "https://github.com/tcptomato/tinytapeout//blob/main/README.md",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "data_in",
                "load_en",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "random bit 0",
                "random bit 1",
                "random bit 2",
                "random bit 3",
                "random bit 4",
                "random bit 5",
                "random bit 6",
                "random bit 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349546262775726676",
            "git_url": "https://github.com/jglim/tt02-bcd-7seg"
        },
        "documentation": {
            "author": "JinGen Lim",
            "discord": "",
            "title": "BCD to 7-Segment Decoder",
            "description": "Converts a BCD input into a 7-segment display output",
            "how_it_works": "The IC accepts four binary-coded decimal input signals, and generates a corresponding 7-segment output signal",
            "how_to_test": "Connect the segment outputs to a 7-segment display. Configure the input (IN0:0, IN1:2, IN2:4, IN3:8). The input value will be shown on the 7-segment display",
            "external_hw": "7-segment display",
            "language": "wokwi",
            "doc_link": "https://github.com/jglim/tt02-bcd-7seg/blob/main/README.md",
            "clock_hz": 0,
            "picture": "ds.svg",
            "inputs": [
                "input 1 (BCD 1)",
                "input 2 (BCD 2)",
                "input 3 (BCD 4)",
                "input 4 (BCD 8)",
                "decimal dot (passthrough)",
                "output invert",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment dot"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "freq_counter.v",
                "shift_reg.v",
                "moving_avg.v",
                "decoder.v"
            ],
            "top_module": "aramsey118_freq_counter",
            "git_url": "https://github.com/ARamsey118/tiny_tapeout_freq_counter"
        },
        "documentation": {
            "author": "Andrew Ramsey",
            "discord": "andrewr#2834",
            "title": "Frequency Counter",
            "description": "Estimates the frequency of an input signal",
            "how_it_works": "'Diffs' (XORs) the previous input with the current one to detect any edges (rising or falling). The edges are then fed into a windowed sum (think moving average, but without the division step). The summation is then converted into a value from 0-9 based on how close to the maximum frequency it is, where 0 is [0, 10)%, 1 is [10, 20)%, etc. which is displayed on the seven segment.",
            "how_to_test": "Input a clock into the clock pin, toggle reset, and verify that the seven segment reads 0. Then apply a test signal and check that the seven segment displays the expected relationship between the clock and test signals. The actual frequency of the clock doesn't matter as long as timing constraints of the chip are met. 1000 Hz makes for convenient math and is a good starting point. If needed, the design will loop the input signal back to the output for a quick sanity check.",
            "external_hw": "Clock and test signal generator",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "signal",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "signal"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "thunderbird_taillight_ctrl.v"
            ],
            "top_module": "thunderbird_taillight_ctrl",
            "git_url": "https://github.com/splinedrive/thunderbird_taillight_1965"
        },
        "documentation": {
            "author": "Hirosh Dabui",
            "discord": "fpga_kian#5918",
            "title": "Taillight controller of a 1965 Ford Thunderbird",
            "description": "Asic of a Taillight controller of a 1965 Ford Thunderbird",
            "how_it_works": "uses a moore statemachine",
            "how_to_test": "after reset, the statemachine runs into idle mode",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": "6250 Hz",
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "left",
                "right",
                "hazard",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "r3",
                "r2",
                "r1",
                "l1",
                "l2",
                "l3",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "fpga.v"
            ],
            "top_module": "gatecat_fpga_top",
            "git_url": "https://github.com/gatecat/tt02-fpga-respin"
        },
        "documentation": {
            "author": "myrtle",
            "discord": "gatecat#6502",
            "title": "FPGA test",
            "description": "small mux2 fpga test",
            "how_it_works": "TODO write up",
            "how_to_test": "TODO write up",
            "external_hw": "TODO write up",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "cfg_frameinc",
                "cfg_framestrb",
                "cfg_mode",
                "cfg_sel0_in0",
                "cfg_sel0_in1",
                "cfg_sel0_in2",
                "cfg_sel0_in3"
            ],
            "outputs": [
                "out 0",
                "out 1",
                "out 2",
                "out 3",
                "out 4",
                "out 5",
                "out 6",
                "out 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341589685194195540",
            "git_url": "https://github.com/mmolteni-secpat/tinytapeout02_chi2shares"
        },
        "documentation": {
            "author": "Maria Chiara Molteni",
            "discord": "Mari-secpat #5370",
            "title": "chi 2 shares",
            "description": "Chi function of Xoodoo protected by TI with two shares",
            "how_it_works": "Chi function of Xoodoo protected by TI with two shares",
            "how_to_test": "Set on the last 4 inputs",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341608574336631379",
            "git_url": "https://github.com/mmolteni-secpat/tinytapeout02_chi3shares"
        },
        "documentation": {
            "author": "Molteni Maria Chiara",
            "discord": "Mari-secpat #5370",
            "title": "chi 3 shares",
            "description": "Chi function of Xoodoo protected by TI with three shares",
            "how_it_works": "Chi function of Xoodoo protected by TI with three shares",
            "how_to_test": "Set on all the inputs",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "whisk.v"
            ],
            "top_module": "wren6991_whisk_tt2_io_wrapper",
            "git_url": "https://github.com/Wren6991/tt02-whisk-serial-processor"
        },
        "documentation": {
            "author": "Luke Wren",
            "discord": "LukeW#3952",
            "title": "Whisk: 16-bit Serial RISC CPU",
            "description": "Execute a simple 16-bit RISC-style instruction set from up to 64 kilobytes of external SPI SRAM.",
            "how_it_works": "Whisk uses a single SPI interface for instruction fetch, loads and stores\non an external SPI SRAM. The SPI serial clock is driven at the same\nfrequency as Whisk's clock input. The program counter, and the six\ngeneral purpose registers, are all 16 bits in size, so up to 64 kilobytes\nof memory can be addressed.\n\nInternally, Whisk is fully serial: registers and the program counter are\nread and written one bit at a time. This matches the throughput of the\nSPI memory interface, and leaves more area free for having more/larger\ngeneral purpose registers as well as leaving room for expansion on future\nTiny Tapeouts.\n\nAn optional IO port interface adds up to 16 outputs and 8 inputs, using\nstandard parallel-in-serial-out and serial-in-parallel-out shift\nregisters. Whisk can read or write these ports in a single instruction.\nThese can be used for bitbanging external hardware such as displays, LEDs\nand buttons.\n",
            "how_to_test": "You will need a Whisk host board, with memory and the host interface to\nload it. See the project GitHub page.\n",
            "external_hw": "- An SPI SRAM with 16-bit addresses and support for sequential mode\n  accesses, e.g. Microchip 23K256T-I\n\n- A host interface for loading and initialising the SPI SRAM, e.g.\n  Raspberry Pi Pico\n\n- (optional) Two 74HC595 shift registers for a 16-bit output port\n\n- (optional) A 74HC166 shift register for an 8-bit input port\n\nAll of these components will be integrated on the Whisk host board, see\nthe project GitHub page.\n",
            "language": "Verilog",
            "doc_link": "https://github.com/Wren6991/tt02-whisk-serial-processor/blob/main/README.md",
            "clock_hz": 6000,
            "picture": "",
            "inputs": [
                "clk",
                "rst_n",
                "mem_sdi",
                "ioport_sdi",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "mem_csn",
                "mem_sck",
                "mem_sdo",
                "ioport_sck",
                "ioport_sdo",
                "ioport_latch_i",
                "ioport_latch_o",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341423712597181012",
            "git_url": "https://github.com/aiunderstand/tt02-4bit-tristate-loadable-counter"
        },
        "documentation": {
            "author": "Steven Bos",
            "discord": "steveb#6973",
            "title": "Scalable synchronous 4-bit tri-directional loadable counter",
            "description": "This chip offers a scalable n-bit counter design that can be used as a program counter by setting the next address (eg. for a JMP instruction). It can work in 3 directions: counting up, down and pause.",
            "how_it_works": "See the full documentation, youtube movie and image. Each 1-bit counter has a flip-flop with count logic component reacting synchronously to the rising edge clock pulse and a count logic component that computes and setup the behavior for the next rising edge using async propagation when the level is low.",
            "how_to_test": "The count state is randomly initialized. Typically the first action is to reset the state to zero by setting the load switch and have one clock pulse. The second action is setting the direction by enabling count and setting countDown to true or false (and disable load). The counter overflows to all 0 when all 1 is reached and count up is set.",
            "external_hw": "no external hardware needed",
            "language": "mixed radix circuit synthesis (MRCS), wokwi",
            "doc_link": "https://github.com/aiunderstand/tt02-4bit-tristate-loadable-counter/blob/main/README.md",
            "clock_hz": 0,
            "picture": "syncbintristateloadablecounter.png",
            "inputs": [
                "clock",
                "count     (0 = disable/countPause, 1 = enable)",
                "load      (0 = count mode, 1 = load mode, overwriting any count logic)",
                "countDown (0 = countUp, 1 = countUp)",
                "addr3     (bits[4:7] are used for loadable count state)",
                "addr2",
                "addr1",
                "addr0"
            ],
            "outputs": [
                "output3 (bits [0:3])",
                "output2",
                "output1",
                "output0",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341277789473735250",
            "git_url": "https://github.com/aiunderstand/tt02-async-binary-ternary-convert-compare"
        },
        "documentation": {
            "author": "Steven Bos",
            "discord": "steveb#6973",
            "title": "Asynchronous Binary to Ternary Converter and Comparator",
            "description": "This chip offers various kinds of conversions and comparisons between binary encoded ternary and unary encoded ternary in both machine readible output and human readible (7-segment display decimal) output",
            "how_it_works": "See the full documentation, youtube movie and image. The chip has four stages. The opcode stage set the mode of the chip. The second stage convert the input to output based on the selected mode. The third stage encoded the output to machine or human based on selected mode. Finally the encoded output is decoded on a 7 segment display.",
            "how_to_test": "Set the chip mode [0:3] to 0111. This enables the chip, set unary encoded ternary channel A conversion and set it to user (decimal) output. Set the input [4:7] to 0010. The Channel A input using Unary Encoded Ternary is set to 2, which the 7 segment display also shows. Note that one combination of the two bits is illegal! (see doc)",
            "external_hw": "no external hardware needed",
            "language": "mixed radix circuit synthesis (MRCS), wokwi",
            "doc_link": "https://github.com/aiunderstand/tt02-async-binary-ternary-convert-compare/blob/main/README.md",
            "clock_hz": 0,
            "picture": "asyncbinterconvcomp.png",
            "inputs": [
                "output mode (0 = human, 1 = machine)",
                "enable (0 = disable, 1 = enable)",
                "opcode0 (see table in documentation for all 4 modes)",
                "opcode1",
                "input channel B pin0 (see table in documentation what is don't care or illegal input for which mode)",
                "input channel B pin1",
                "input channel A pin0",
                "input channel A pin1"
            ],
            "outputs": [
                "segment a (the 7 segment is used for human readable output, sometimes using decimals and sometimes using comparison symbols, see documentation for more details)",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment dot (the dot is an extra indicator that the output is in machine format)"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "348787952842703444",
            "git_url": "https://github.com/RobertRiachi/tt02-dot-product"
        },
        "documentation": {
            "author": "Robert Riachi",
            "discord": "",
            "title": "Vector dot product",
            "description": "Compute the dot product of two 2x1 vectors each containing 2 bit integers",
            "how_it_works": "a := in[0:1], b := in[2:3], c := in[4:5], d := in[6:7] - [a,b,c,d] => [ac * bd]",
            "how_to_test": "set input to 11011010 => which means [11,01]\u22c5[10,10] => as ints [3,1]\u22c5[2,2] => output should be 00001000 => (3*2) + (1*2) = 8",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "mcpi.v"
            ],
            "top_module": "regymm_mcpi",
            "git_url": "https://github.com/regymm/tt02-verilog-mcpi"
        },
        "documentation": {
            "author": "regymm",
            "discord": "regymm#4892",
            "title": "Monte Carlo Pi Integrator",
            "description": "Calculate the value of Pi using the Monte Carlo method",
            "how_it_works": "Having random x and y between 0 to 1 and compare the added squares with 1. Using 8-bit fixed-point number.",
            "how_to_test": "SW 00: counter shows total sample points. SW 01: counter shows sample points inside 1 radius. SW 10: counter 0 and 1 will toggle, 0 for every sample point and 1 for inside point, for use with external counter. ",
            "external_hw": "External edge counter recommended(funnyblinky is a possible choice)",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "sw control 0",
                "sw control 1",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "counter 0",
                "counter 1",
                "counter 2",
                "counter 3",
                "counter 4",
                "counter 5",
                "counter 6",
                "counter 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "funnyblinky.v"
            ],
            "top_module": "regymm_funnyblinky",
            "git_url": "https://github.com/regymm/tt02-verilog-funnyblinky"
        },
        "documentation": {
            "author": "regymm",
            "discord": "regymm#4892",
            "title": "Funny Blinky",
            "description": "Blink the 8 output LEDs in a funny way.",
            "how_it_works": ".",
            "how_to_test": "When function switch is turned off, all LEDs will be blinky. When switch is on, it works as a double 14-bit counter, to be used together with the mcpi module -- in this case we have pause switch and two output control switches to show all bits of the counters. ",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "switch out ctrl 0",
                "switch out ctrl 1",
                "switch pause",
                "switch function"
            ],
            "outputs": [
                "led 0",
                "led 1",
                "led 2",
                "led 3",
                "led 4",
                "led 5",
                "led 6",
                "led 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "gps_ca_prn.v"
            ],
            "top_module": "adamgreig_tt02_gps_ca_prn",
            "git_url": "https://github.com/adamgreig/tt02-gpa-ca-prn"
        },
        "documentation": {
            "author": "Adam Greig",
            "discord": "adamgreig#1307",
            "title": "GPS C/A PRN Generator",
            "description": "Generate the GPS C/A PRN sequences PRN1 through PRN32",
            "how_it_works": "Two LFSRs are constructed per the GPS ICD, and the first is added to selected taps of the second to produce the selected final PRN sequence.",
            "how_to_test": "With io_in[2:7] set to 2 to select PRN2, reset and then drive the clock; the output sequence on io_out[2] will start with 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1.",
            "external_hw": "None",
            "language": "Amaranth",
            "doc_link": "https://github.com/adamgreig/tt02-gps-ca-prn",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "prn[0]",
                "prn[1]",
                "prn[2]",
                "prn[3]",
                "prn[4]",
                "none"
            ],
            "outputs": [
                "G1",
                "G2",
                "Selected PRN",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "adc_dac.v"
            ],
            "top_module": "adamgreig_tt02_adc_dac",
            "git_url": "https://github.com/adamgreig/tt02-adc-dac"
        },
        "documentation": {
            "author": "Adam Greig",
            "discord": "adamgreig#1307",
            "title": "Sigma-Delta ADC/DAC",
            "description": "Simple ADC and DAC",
            "how_it_works": "This project is built on a simple sigma-delta DAC. The DAC is given an n-bit\ncontrol word and generates a single-bit digital output where the pulse\ndensity is proportional to that control word. By integrating this pulse\ntrain, for example with an RC filter, an analogue output voltage is produced.\n\nThe ADC operates by generating an analogue output voltage which is compared\nto the analogue input by an off-chip comparator. The comparator result is\nused as a digital input to a simple control loop that adjusts the output\nvoltage so that it tracks the input signal. The control word for the DAC\ngenerating the output voltage is then the ADC reading. This control word\nis regularly transmitted as hex-encoded ASCII over a UART running at the\nclock rate.\n\nA second dedicated 8-bit DAC is controlled by received words over a UART.\nTransmit the control word at 1/10th the clock speed into `uart_in`, and\nadd a second external RC circuit to filter `dac_out` to an analogue voltage.\n",
            "how_to_test": "Ensure in[0] is clocked. Connect out[0] through a series resistor to both\na capacitor to ground and the non-inverting input of a comparator. Connect\nthe analogue input to measure to the inverting input, and connect the\ncomparator output to in[2]. Connect out[1] to a UART receiver at the clock\nrate and receive ADC readings as hex-encoded ASCII lines.\n\nConnect out[2] to a second RC filter, and feed one-byte DAC settings\nto the UART on in[3] at a baud rate 1/10th the clock. Measure the\nresulting analogue output.\n",
            "external_hw": "Comparator, resistor, capacitor",
            "language": "Amaranth",
            "doc_link": "https://github.com/adamgreig/tt02-adc-dac",
            "clock_hz": 6000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "adc_in",
                "uart_in",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "adc_out",
                "uart_out",
                "dac_out",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "jglim_7seg.v",
                "hex7seg.v"
            ],
            "top_module": "jglim_7seg",
            "git_url": "https://github.com/jglim/tt02-bcd-hex7seg-hdl"
        },
        "documentation": {
            "author": "JinGen Lim",
            "discord": "",
            "title": "BCD to Hex 7-Segment Decoder",
            "description": "Converts a 4-bit BCD input into a hexadecimal 7-segment display output",
            "how_it_works": "The IC accepts four binary-coded decimal input signals, and generates a corresponding hexadecimal 7-segment output signal. Segment outputs may be inverted with the INVERT pin to support both common cathode/anode displays.",
            "how_to_test": "Connect the segment outputs to a 7-segment display. Configure the input (IN0:0, IN1:2, IN2:4, IN3:8). The input value will be shown on the 7-segment display",
            "external_hw": "7-segment display",
            "language": "verilog",
            "doc_link": "https://github.com/jglim/tt02-bcd-hex7seg-hdl/blob/main/README.md",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "input 1 (BCD 1)",
                "input 2 (BCD 2)",
                "input 3 (BCD 4)",
                "input 4 (BCD 8)",
                "decimal dot (passthrough)",
                "output invert",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment dot"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349790606404354643",
            "git_url": "https://github.com/burtyb/tt02-srld"
        },
        "documentation": {
            "author": "Chris Burton",
            "discord": "burtyb#2164",
            "title": "SRLD",
            "description": "8-bit Shift Register with latch and hex decode to display alternating nibbles",
            "how_it_works": "Data is inputted to an 8-bit shift register, the data can then be (optionally) latched, data can be switched around if needed based on shifted data being LSB/MSB first, cylcles between decoding high/low nibble to show on the 7-segment display.",
            "how_to_test": "Use shiftIn and shiftClk to clock in 8-bits of data. Toggle latch to move data from shift register to the latch. 7-seg display will show alternating high/low nibbles. If useLatch is high data comes from the latch otherwise it will be shown 'live' as it's shifted in. If cycle_display is low the display will cycle between high/low nibble otherwise it will show the nibble selected by lowHighNibble. mslLsb will switch between showing the shifted data as MSB or LSB first.",
            "external_hw": "Switches and 7-segment display",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 16,
            "picture": "",
            "inputs": [
                "displayClock",
                "shiftIn",
                "shiftClk",
                "latch",
                "cycle_display",
                "lowHighNibble",
                "useLatch",
                "mslLsb"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "High/low nibble indicator"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341279123277087315",
            "git_url": "https://github.com/azzeloof/tt02-counter"
        },
        "documentation": {
            "author": "Adam Zeloof",
            "discord": "Adam#2299",
            "title": "Counter",
            "description": "It counts!",
            "how_it_works": "It counts up or displays an entered number on the seven-segment. A clock divider can be used to slow down the clock speed.",
            "how_to_test": "Enable the counter (input 7) and the clock divider (input 6) and it should start counting up. If you disable the counter (input 7) you can enter a number to display manually in binary (inputs 1-4).",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "https://github.com/azzeloof/tt02-counter",
            "clock_hz": 600,
            "picture": "assets/image.jpg",
            "inputs": [
                "clock",
                "b0",
                "b1",
                "b2",
                "b3",
                "none",
                "clock divider enable",
                "count enable"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "alu.v"
            ],
            "top_module": "shan1293_2bitalu",
            "git_url": "https://github.com/shan1293/tt02-2bitCPU"
        },
        "documentation": {
            "author": "shan",
            "discord": "shan1293",
            "title": "2bitALU",
            "description": "2 bit ALU which performs 16 different operations",
            "how_it_works": "Based on the 4 bit opcode, the ALU performs 16 different operations on the 2 bit inputs A & B and stores the result in 8 bit output ALU_out",
            "how_to_test": "Provide A, B inputs. Select opcode based on the operation to perform. Check output at ALU_out",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": "none",
            "picture": "",
            "inputs": [
                "A1",
                "A2",
                "B1",
                "B2",
                "opcode",
                "opcode",
                "opcode",
                "opcode"
            ],
            "outputs": [
                "ALU_out",
                "ALU_out",
                "ALU_out",
                "ALU_out",
                "ALU_out",
                "ALU_out",
                "ALU_out",
                "ALU_out"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349729432862196307",
            "git_url": "https://github.com/Josvth/tt02-convolutional-encoder"
        },
        "documentation": {
            "author": "Jos van 't Hof",
            "discord": "josvth#1973",
            "title": "A (7, 1/2) Convolutional Encoder",
            "description": "A (7, 1/2) Convolutional Encoder following the CCSDS 131.0-B-4 standard.",
            "how_it_works": "A Convolutional Encoder adds additional bits to a data stream or message that may later be used to correct errors in the transmission of the data. The specific implemented encoder is used in space applications and is a half-rate (R = 1/2) code with a constrain lenght of seven (K = 7). This means that the encoder generates two output bits (called symbols) for every input bit, and the encoder has m = K - 1 = 6 states.",
            "how_to_test": "Pull the write_not_shift input (IN1) high and set a 6-bit binary input (using IN2 to IN7), for example 0b100110. Provide a clock cycle on the clock input (IN0) to write the input into the shift register and clear the encoder. Pull the write_not_shift input (IN2) low to start shifting. Provide 24 clock cycles (2 each for the 6 shift registers and 6 encoder registers 2x(6+6) = 24). After each clock cycle a 0 or 1 is displayed on the 8-segment display. The encoded output for the input 0b100110 is 0b10111|0010001101000111001. The first 6 bits of the encoded output may be discared.",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "https://github.com/Josvth/tt02-convolutional-encoder/blob/main/README.md",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "write_not_shift",
                "shift_input_0",
                "shift_input_1",
                "shift_input_2",
                "shift_input_3",
                "shift_input_4",
                "shift_input_5"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment dp (used to indicate clock)"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "pic.v"
            ],
            "top_module": "tiny_kinda_pic",
            "git_url": "https://github.com/gatecat/tt02-pic"
        },
        "documentation": {
            "author": "myrtle",
            "discord": "gatecat#6502",
            "title": "Tiny PIC-like MCU",
            "description": "serially programmed, subset of PIC ISA, MCU",
            "how_it_works": "Implements a subset of the PIC mid-range ISA (no SFR, no carry, no call/stack), 6 GPRs, 16 program words.",
            "how_to_test": "Program data is shifted in serially. For each program word, shift in {(1 << address), data} (28 bits total) to prog_data and then assert prog_strobe. Once loaded, deassert (bring high), reset and the program should start running. GPR 6 is GPI and GPR 7 is GPO",
            "external_hw": "A means of shifting in the program (e.g. another microcontroller, USB GPIO interface, etc) is required at startup. Once running, it is standalone.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "prog_strobe",
                "prog_data",
                "gpi0",
                "gpi1",
                "gpi2",
                "gpi3"
            ],
            "outputs": [
                "gpo0",
                "gpo1",
                "gpo2",
                "gpo3",
                "gpo4",
                "gpo5",
                "gpo6",
                "gpo7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "browndeer_rv8u.v",
                "des.v",
                "registers.v"
            ],
            "top_module": "browndeer_rv8u",
            "git_url": "https://github.com/browndeer/rv8u"
        },
        "documentation": {
            "author": "David Richie",
            "discord": "",
            "title": "RV8U - 8-bit RISC-V Microcore Processor",
            "description": "8-bit processor based on RISC-V ISA",
            "how_it_works": "Executes reduced RISC-V based ISA",
            "how_to_test": "Requires interfacing to external memory",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "serdes input bit 0",
                "serdes input bit 1",
                "serdes input bit 2",
                "serdes input bit 3",
                "serdes input bit 4",
                "serdes input bit 5"
            ],
            "outputs": [
                "serdes output bit 0",
                "serdes output bit 1",
                "serdes output bit 2",
                "serdes output bit 3",
                "serdes output bit 4",
                "serdes output bit 5",
                "serdes output bit 6",
                "serdes output bit 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341432030163108435",
            "git_url": "https://github.com/Sirawit7205/tt02-2G97-2G98"
        },
        "documentation": {
            "author": "Sirawit Lappisatepun",
            "discord": "SL7205#1215",
            "title": "Logic-2G97-2G98",
            "description": "Replication of TI's Little Logic 1G97 and 1G98 configurable logic gates.",
            "how_it_works": "This design replicates the circuit inside a TI configurable logic gates 74xx1G97 (and by including an inverted output, it will work as a 74xx1G98 as well). Since there are still I/O pins left, I included two of these configurables, and also one 74xx1G79 D Flip-Flop (again, an inverted output means this will also work as a 74xx1G80).",
            "how_to_test": "You could refer to TI's 1G79/1G80/1G97/1G98 datasheet to test the device according to the pinout listed below.",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "dff_clock",
                "dff_data",
                "gate1_in0",
                "gate1_in1",
                "gate1_in2",
                "gate2_in0",
                "gate2_in1",
                "gate2_in2"
            ],
            "outputs": [
                "dff_out",
                "dff_out_bar",
                "gate1_out",
                "gate1_out_bar",
                "gate2_out",
                "gate2_out_bar",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "melody.v"
            ],
            "top_module": "prog_melody_gen",
            "git_url": "https://github.com/gatecat/tt02-melody-gen"
        },
        "documentation": {
            "author": "myrtle",
            "discord": "myrtle#6502",
            "title": "Melody Generator",
            "description": "plays a melody, preloaded with jingle bells but re-programmable",
            "how_it_works": "melody output at output 0",
            "how_to_test": "connect a speaker to output 0, set reload and restart to 1",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 25000,
            "picture": "",
            "inputs": [
                "clock",
                "reload",
                "restart",
                "prog_data",
                "prog_strobe",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "melody",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "rotaryencoder.v",
                "decoder.v"
            ],
            "top_module": "vaishnavachath_rotary_toplevel",
            "git_url": "https://github.com/vaishnavachath/tt02-submission-rotary-encoder-counter"
        },
        "documentation": {
            "author": "Vaishnav Achath",
            "discord": "vaishnav#8610",
            "title": "Rotary Encoder Counter",
            "description": "Count Up/Down on the 7-segment accouring to rotary encoder input",
            "how_it_works": "uses a register and some combinational logic",
            "how_to_test": "Provides test mode enable to use input clock and inverted ip/clock as emulated encoder CLK/Data",
            "external_hw": "Rotary Encoder",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset_rotary_SW",
                "rotary_outa",
                "rotary_outb",
                "test_mode_enable",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341614346808328788",
            "git_url": "https://github.com/maehw/tt02-wokwi-wolf-goat-cabbage"
        },
        "documentation": {
            "author": "maehw",
            "discord": "maehw#7519",
            "title": "Wolf sheep cabbage river crossing puzzle ASIC design",
            "description": "Play the wolf, goat and cabbage puzzle interactively.",
            "how_it_works": "Truth table with the game logic (hidden easter egg). The inputs are the positions of the farmer, wolf, goat and cabbage. The 7-segment display shows the status of the game (won or lost).",
            "how_to_test": "Slide the input switches, think, have a look at the 7-segment display.",
            "external_hw": "Input switches and 7-segment display",
            "language": "wokwi",
            "doc_link": "https://github.com/maehw/tt02-wokwi-wolf-goat-cabbage/blob/main/README.md",
            "clock_hz": 0,
            "wokwi_id": 341614346808328788,
            "picture": "wokwi-simulation-io-mapping.png",
            "inputs": [
                "not connected because it is typically used for clocked designs and may be used in the future of this design",
                "input signal F for the position of the farmer",
                "input signal W for the position of the wolf",
                "input signal G for the position of the goat",
                "input signal C for the position of the cabbage",
                "here be dragons or an easter egg",
                "unused",
                "unused"
            ],
            "outputs": [
                "output signal ~E, i.e. the top and bottom segments light up, when the game is over due to an unattended situation on any river bank side",
                "output signal ~R i.e. the top-right and bottom-right segments light up, to indicate an unattended situation on the right river bank (game over)",
                "output signal ~R i.e. the top-right and bottom-right segments light up, to indicate an unattended situation on the right river bank (game over)",
                "output signal ~E, i.e. the top and bottom segments light up, when the game is over due to an unattended situation on any river bank side",
                "output signal ~L i.e. the top-left and bottom-left segments light up, to indicate an unattended situation on the left river bank (game over)",
                "output signal ~L i.e. the top-left and bottom-left segments light up, to indicate an unattended situation on the left river bank (game over)",
                "here be dragons or an easter egg",
                "output signal A to light up the \"dot LED\" of the 7 segment display as an indicator that all objects have reached the right bank of the river and the game is won! \ud83c\udf89\ud83c\udf89\ud83c\udf89"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341631511790879314",
            "git_url": "https://github.com/maehw/tt02-wokwi-lowspeed-tiny-uart"
        },
        "documentation": {
            "author": "maehw",
            "discord": "maehw#7519",
            "title": "Low-speed UART transmitter with limited character set loading",
            "description": "Low baudrate UART transmitter (8N1) with limited character set (0x40..0x5F; includes all capital letters in the ASCII table) loading.",
            "how_it_works": "The heart of the design is a 13 bit shift register (built from D flip-flops). When a word has been transmitted, it will be transmitted again and again until a new word is loaded into the shift register or the output is disabled (the word will keep on cycling internally).",
            "how_to_test": "Load a character into the design and attach a UART receiver (or oscilloscope or logic analyzer) on the output side.",
            "external_hw": "UART receiver or oscilloscope or logic analyzer (optional)",
            "language": "wokwi",
            "doc_link": "https://github.com/maehw/tt02-wokwi-lowspeed-tiny-uart/blob/main/README.md",
            "clock_hz": 9600,
            "picture": "wokwi-simulation-io-mapping.png",
            "inputs": [
                "300 Hz input clock signal (or different value supported by the whole",
                "bit b0 (the least significant bit) of the loaded and transmitted character",
                "bit b1 of the loaded and transmitted character",
                "bit b2 of the loaded and transmitted character",
                "bit b3 of the loaded and transmitted character",
                "bit b4 of the loaded and transmitted character",
                "load word into shift register from parallel input (IN1..IN5) (1) or cycle the existing word with start/stop bits around it (0)",
                {
                    "output enable (for gated output signals)": "1 output is enabled, 0 output is disabled (permanently set to HIGH/1)"
                }
            ],
            "outputs": [
                "UART (serial output pin, direct throughput)",
                "UART (serial output pin, gated by enable signal)",
                "UART (serial output pin, reverse polarity, direct throughput)",
                "UART (serial output pin, reverse polarity, gated by enable signal)",
                "UART (MSBit, direct throughput); typically set to 1 or can be used to sniffing the word cycling through the shift register)",
                "UART (MSBit, reverse polarity, direct throughput); same usage as above",
                "UART (MSBit, gated by enable signal); typically set to 1 or can be used to sniffing the word cycling through the shift register)",
                "UART (MSBit, reverse polarity, gated by enable signal); same usage as above"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "rotary_encoder.v",
                "decoder.v"
            ],
            "top_module": "rotary_encoder",
            "git_url": "https://github.com/wimdams/tt02-rotary-encoder"
        },
        "documentation": {
            "author": "Wim Dams",
            "discord": "wda#2504",
            "title": "Rotary encoder",
            "description": "Reads in a (incremental) rotary encoder and shows the result on the seven-segment display",
            "how_it_works": "The rotary pins are sampled every clock cycle. If a rising edge is detected on pin A, the 4 bit counter will be incremented/decremented depending on pin B. The counter is put on the seven segment display and a debounce time is started (125 clk cycles) ",
            "how_to_test": "After reset, turn the rotary encoder and the counter should increment/decrement as you turn",
            "external_hw": "Rotary encoder connected to pin A and pin B",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 10000,
            "picture": "doc/rotary_encoder.png",
            "inputs": [
                "clock",
                "reset",
                "Rotary encoder pin A (sometimes marked as CLK)",
                "Rotary encoder pin B (sometimes marked as DT)",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "frog.v"
            ],
            "top_module": "frog",
            "git_url": "https://github.com/ChrisPVille/tt02-FROG4bitCPU"
        },
        "documentation": {
            "author": "ChrisPVille",
            "discord": "Lost LLama#9711",
            "title": "FROG 4-Bit CPU",
            "description": "The FROG is an extremely minimal load-store 4-bit CPU",
            "how_it_works": "The CPU addresses external memory on its addr pins and executes/interprets data on the data_in pins",
            "how_to_test": "Set data_in to 0x8 (NOP) and observe the addr bus count upward as the CPU executes Instructions",
            "external_hw": "An SRAM/ROM like memory containing instructions should be connected to addr/wcyc/data_in",
            "language": "verilog",
            "doc_link": "README.md",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset_p",
                "data_in[0]",
                "data_in[1]",
                "data_in[2]",
                "data_in[3]",
                "none",
                "fast - zero wait state memory mode"
            ],
            "outputs": [
                "addr[0]",
                "addr[1]",
                "addr[2]",
                "addr[3]",
                "addr[4]",
                "addr[5]",
                "addr[6]",
                "write memory cycle"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "swalense_top.v"
            ],
            "top_module": "swalense_top",
            "git_url": "https://github.com/swalense/tt02-graycode_counter"
        },
        "documentation": {
            "author": "Eric Swalens",
            "discord": "rxvoid#0294",
            "title": "Configurable Gray Code Counter",
            "description": "A configurable counter driven by 2-channel Gray code",
            "how_it_works": "The module is an 8-bit configurable counter modified by Gray code (aka 2-bit quadrature code);\nit aims at easing the integration of incremental rotary encoders into projects.\nThe counter value is given as a (truncated to 5 bits) parallel or (8 bits, no parity, 1 stop bit) serial UART output.\nOther outputs include the \"direction\" of progression of the Gray code, and a PWM signal for which the duty cycle is proportional to the counter value.\n\nSome basic (optional) debouncing logic is included; any pulse inverting the direction must be followed by a second pulse in the same direction\nbefore the change is registered.\n\nAdditional features include support for wrapping (the counter rolls over at the minimum and maximum value),\nand a \"gearbox\" that selects the X1 (1 pulse per 4 transitions), X2 (2 pulses) or X4 (4 pulses) output of the Gray code decoder driving the counter\ndepending on the speed at which the channels change; this can provide some form of \"acceleration\".\nThe initial and maximum values of the counter can also be set.  \n\nEncoders with twice the number of detents compared to the number of pulses per round (e.g. 24 detents / 12 PPR) are supported \nby setting the input \"update on X2\" high or forcing it with the configuration parameter.\n\nAfter reset the module is configured as a basic 5-bit counter which can then be further modified by sending a 32-bit word over the SPI interface.\nThis word sets the following options (reset value between parentheses):\n\n- gearbox enable (0)\n\n- debounce logic enable (1)\n\n- wrap enable (0)\n\n- Gray code value for X1 (0)\n\n- force update on X2 (0), this overrides a low value at the input pin (the value for X1 selects which transitions are taken into consideration)\n\n- gearbox timer value (n/a, gearbox is disabled)\n\n- counter initial value (0)\n\n- counter maximum value (31)\n\nSee link to GitHub for possible errata.\n",
            "how_to_test": "For a basic test connect a device generating Gray code and retrieve the counter value at the parallel or serial outputs with a microcontroller or other circuitry.\n\nTo further configure the module send some configuration word over the SPI interface (mode 0, MSB first, CS is active low).\nThe 32-bit configuration word is constructed a follows (bits between brackets):\n\n- [24:31] maximum counter value\n\n- [16:23] initial counter value after configuration\n\n- [8:15] gearbox timer\n\n- [6:7] unused\n\n- [5:5] force update on X2\n\n- [3:4] X1 value\n\n- [2:2] debounce enable\n\n- [1:1] wrap enable\n\n- [0:0] gearbox enable\n\nThe gearbox is implemented with a 5-bit threshold value; it is incremented by the X4 output of the decoder and decremented by a timer\n(this threshold is then divided by 8 to select the gear, giving 0: X1, 1: X1, 2/3: X4).\nTherefore the result depends on the clock frequency and the speed at which the Gray code transitions. The gearbox timer is exposed to enable tuning\nthe interval between two updates by the timer.\nFor a rotary encoder with detents one can suggest using *clock_hz / (detents x transitions - 16)* as a starting point to determine a suitable value,\nwhere detents is the number per turn (e.g. 24) and transitions is the number per detent (e.g. 4). That is, 62 for a common 24 detents / 24 PPR encoder.\n\nThe 8-N-1 UART serial output shifts 1 bit out at each clock cycle. The receiving serial port therefore needs to be configured at the same speed as the clock.\n\nThe PWM frequency is derived from the maximum counter value. It might be unsuitable for visual feedback, e.g. driving a LED, for large values with a low\nclock frequency as the LED will appear blinking.\n",
            "external_hw": "A source of Gray code; filtering and Schmitt triggers may be required if a mechanical encoder is used.\n",
            "language": "Amaranth",
            "doc_link": "https://github.com/swalense/tt02-graycode_counter#readme",
            "clock_hz": 5000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "channel A",
                "channel B",
                "update on X2",
                "SPI CS",
                "SPI SCK",
                "SPI SDI"
            ],
            "outputs": [
                "UART serial output",
                "PWM signal",
                "direction",
                "counter bit 0",
                "counter bit 1",
                "counter bit 2",
                "counter bit 3",
                "counter bit 4"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "luthor2k_top_tto.v",
                "main.v"
            ],
            "top_module": "luthor2k_top_tto",
            "git_url": "https://github.com/Luthor2k/tt02-baudot"
        },
        "documentation": {
            "author": "Arthur Hazleden",
            "discord": "L2K20",
            "title": "Baudot Converter",
            "description": "This circuit will convert ASCII serial data to baudot serial data provide the reverse funtion as well",
            "how_it_works": "UARTS and two conversion ROMs",
            "how_to_test": "Serial data in and see how it goes.",
            "external_hw": "The ASCII is expected to come in/out from a USB-serial adapter. The baudot is a 60mA current loop so something hefty is required.",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "ascii clock at 8x desired baudrate",
                "baudot clock at 100x desired baudrate",
                "baudot input, should be held high when line is idle but connected",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349886696875098706",
            "git_url": "https://github.com/ctag/tt02-submission-ctag"
        },
        "documentation": {
            "author": "Christopher 'ctag' Bero",
            "discord": "ctag#6984",
            "title": "Marquee",
            "description": "Scrolls 'ctag' across the 7seg.",
            "how_it_works": "Uses two flip-slops to get a 4-state machine, and then just activates LEDs from the outputs.",
            "how_to_test": "Set clock to button and click through.",
            "external_hw": "NA/Button",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 2,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "Asma_Mohsin_conv_enc_core.v"
            ],
            "top_module": "Asma_Mohsin_conv_enc_core",
            "git_url": "https://github.com/AsmaMohsin1507/tt02-channel-coding"
        },
        "documentation": {
            "author": "Asma Mohsin",
            "discord": "Asma Mohsin#8645",
            "title": "channel coding",
            "description": "Convolutional coding is widely used in modern digital communication systems.We often get encoded data by using different polynomials having same constraint lengths (K).",
            "how_it_works": "We have two polynomials of 4th order and a shift register of 5 bits. we take input data of a single bit and put it in shift register on each clock edge as long as valid data bit is asserted. after this codeword is calculated by taking xor of the and of polynomial and shift register",
            "how_to_test": "apply clk,reset ,data valid and input data and do calculations to see if output is equal to the desired one",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "https://github.com/AsmaMohsin1507/tt02-channel-coding/blob/cccf2f01c80024d59eef60c292b57c8786c9e495/README.md",
            "clock_hz": 6000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "data valid",
                "data input",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "encoded data",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "stevenmburns_toplevel.v",
                "ScanBinary.v"
            ],
            "top_module": "stevenmburns_toplevel",
            "git_url": "https://github.com/stevenmburns/tt02-scannable-gcd"
        },
        "documentation": {
            "author": "Steve Burns",
            "discord": "",
            "title": "Chisel 16-bit GCD with scan in and out",
            "description": "Simple chisel based design based on Knuth's BinaryGDC algorithm using scan chains for I/O.",
            "how_it_works": "With the `ld` signal true, the `u_bit` and `v_bit` inputs are used to scan the `n`-bit numbers into the block. Simulataneously, the high-order bit of the `u` register is scanned out, allowing access to the result of the last computation. Upon lowering the `ld` signal, the Euclid iteration starts. When done, the `done` signal is raised.",
            "how_to_test": "Chiseltest enabled tests. Go to `chisel` and run `sbt test`.",
            "external_hw": "None",
            "language": "Chisel",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "ld",
                "u_bit",
                "v_bit",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "z_bit",
                "done",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341546888233747026",
            "git_url": "https://github.com/cy384/tt02-submission-template"
        },
        "documentation": {
            "author": "cy384",
            "discord": "cy384#9852",
            "title": "Adder with 7-segment decoder",
            "description": "Four bit adder with binary to 7 segment display decoder",
            "how_it_works": "Four full adders with carry feeding into a somewhat hairy binary to seven segment display decoder.",
            "how_to_test": "Use the DIP switches to enter two four bit binary numbers.  Display of numbers greater than nine is questionable.  The decimal point of the display is carry (i.e. a sum over 16).",
            "external_hw": "No external hardware needed.",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "screenshot.png",
            "inputs": [
                "first number bit 0 (least significant)",
                "first number bit 1",
                "first number bit 2",
                "first number bit 3",
                "second number bit 0 (least significant)",
                "second number bit 1",
                "second number bit 2",
                "second number bit 3"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment DP (carry bit)"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "rglenn_hex_to_7_seg.v",
                "decoder.v"
            ],
            "top_module": "rglenn_hex_to_7_seg",
            "git_url": "https://github.com/rglenn/tt02-rglenn-hex-to-7-seg"
        },
        "documentation": {
            "author": "Randy Glenn",
            "discord": "rglenn#6732",
            "title": "Hex to 7 Segment Decoder",
            "description": "Displays an input 4-bit value as a hex digit",
            "how_it_works": "A modern take on the classic TIL311",
            "how_to_test": "after reset, the counter should increase by one every second",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "latch",
                "blank",
                "data 0",
                "data 1",
                "data 2",
                "data 3",
                "decimal",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "decimal"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "zymason.sv"
            ],
            "top_module": "zymason_tinytop",
            "git_url": "https://github.com/zymason/tt02-zymason"
        },
        "documentation": {
            "author": "Zach Mason",
            "discord": "iamzach6#4996",
            "title": "Multiple seven-segment digit buffer",
            "description": "Storage and variable speed readback segment digits",
            "how_it_works": "Stores 12 seven-segment display digits in registers in write mode. In read mode, the values are sequentially displayed back, with a variable cycle rate. The segment inputs are 4-3 multiplexed and a clock divider is used to slow down the output rate. The user is responsible for tracking how many digits have been set.\n",
            "how_to_test": "First set in1-in7 low, and then reset by toggling in1 high then low. In read mode (in2 high), the decimal point will be illuminated and the first 4 segments can be changed with in4-in7. When the desired configuration is set, sel (in3) can be switched high and the remaining 3 segments can be set with in4-in6. Once the desired configuration is set, you can move to the next digit by bringing sel (in3) low. Alternatively, read mode can be entered by bringing RW (in2) low. At this point, the stored values will begin reading sequentially at a rate given by in4-in7. The base period is about 81.9ms, with in4-in7 specifying the multiplication factor for the real display rate. The slowest period is about 2.62s, where in7-in4 are all high. If in read mode, bringing in3 low will stop the cycling and keep displaying the current digit. This can be useful for changing a single digit since one could cycle through at a slow rate to find the target, enter write mode, change the stored digit, and then exit back to read mode.\n",
            "external_hw": "None",
            "language": "SystemVerilog",
            "doc_link": "None",
            "clock_hz": 6250,
            "picture": "doc/diagram.png",
            "inputs": [
                "clock",
                "reset",
                "RW mode",
                "sel, read_clk_en",
                "pin0, clkspd0",
                "pin1, clkspd1",
                "pin2, clkspd2",
                "pin3, clkspd3"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment dp"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341178481588044372",
            "git_url": "https://github.com/DaveyPocket/chaser_tt2"
        },
        "documentation": {
            "author": "Bradley Boccuzzi",
            "discord": "DaveyPocket#3295",
            "title": "LED Chaser",
            "description": "Push the button to fill in segments of the LED display, they will continue to shift and fill in the display until the button is released.`",
            "how_it_works": "Input is button to input of shift register. Each segment of the 7 segment display is connected to an output of the shift register.",
            "how_to_test": "Push switch number 8 to watch the LEDs fill in",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "shift register input"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "klei22_ra.v",
                "shift_register_line.v",
                "rolling_average.v"
            ],
            "top_module": "klei22_ra",
            "git_url": "https://github.com/klei22/Rolling-Average"
        },
        "documentation": {
            "author": "Kauna Lei",
            "discord": "akuna#2874",
            "title": "Rolling Average - 5 bit, 8 bank",
            "description": "5bit moving average",
            "how_it_works": "Using Shift Register Line and Rolling Sum Trick",
            "how_to_test": "Clock in the high 5 bits of io_in (io_in[7:3]) with the i_data_clk (io_in[2]) (active high), and read output on io_out[4:0]",
            "external_hw": "gpios to connect with io_in[7:2] and to read io_out[4:0]",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "i_data_clk",
                "i_value[0]",
                "i_value[1]",
                "i_value[2]",
                "i_value[3]",
                "i_value[4]"
            ],
            "outputs": [
                "ra_out[0]",
                "ra_out[1]",
                "ra_out[2]",
                "ra_out[3]",
                "ra_out[4]",
                0,
                0,
                0
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "w5s8.v"
            ],
            "top_module": "afoote_w5s8_tt02_top",
            "git_url": "https://github.com/andars/tt02-universal-turing-machine-w5s8"
        },
        "documentation": {
            "author": "Andrew Foote",
            "discord": "",
            "title": "w5s8: universal turing machine core",
            "description": "State transition logic for a 5-state, 8-symbol universal turing machine",
            "how_it_works": "Uses combinational logic to implements a (state, symbol) -> (state, symbol, direction) transition function",
            "how_to_test": "Provide state & symbol as inputs, and the module should output the state, symbol, and direction according to the table in test.py.",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "https://github.com/andars/tt02-universal-turing-machine-w5s8#readme",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "state_in[0]",
                "state_in[1]",
                "state_in[2]",
                "sym_in[0]",
                "sym_in[1]",
                "sym_in[2]",
                "mode"
            ],
            "outputs": [
                "none",
                "next_direction",
                "new_sym[0]",
                "new_sym[1]",
                "new_sym[2]",
                "new_state[0]",
                "new_state[1]",
                "new_state[2]"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349255310782759507",
            "git_url": "https://github.com/ternary-info/tt02-submission-shaos3"
        },
        "documentation": {
            "author": "Shaos",
            "discord": "Shaos#3571",
            "title": "Test3",
            "description": "Binary Coded Ternary Test",
            "how_it_works": "Should work as ternary selector",
            "how_to_test": "Set inputs, read outputs",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "wokwi-sch.png",
            "inputs": [
                "C+",
                "C-",
                "N+",
                "N-",
                "O+",
                "O-",
                "P+",
                "P-"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "dot"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "rtl/bcd_counter.v",
                "rtl/bcd_decoder.v",
                "rtl/clock.v",
                "rtl/ctrl.v",
                "rtl/mux_6_4b.v",
                "rtl/output_sr.v",
                "rtl/rise_edge.v",
                "rtl/top.v"
            ],
            "top_module": "gregdavill_clock_top",
            "git_url": "https://github.com/gregdavill/tt02-clock"
        },
        "documentation": {
            "author": "Greg Davill",
            "discord": "Greg#9468",
            "title": "Seven Segment Clock",
            "description": "Logic to drive 6 external 74hct595's that in turn drive 7 segment displays. The displays form a digital clock.",
            "how_it_works": "TBD",
            "how_to_test": "TBD",
            "external_hw": "6x 74hct595's, 6x 7segment",
            "language": "verilog",
            "doc_link": "TBD",
            "clock_hz": "128Hz",
            "picture": "TBD",
            "inputs": [
                "clock",
                "reset",
                "minute_up",
                "hour_up",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "sclk",
                "latch",
                "data",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "rtl/top.v",
                "rtl/scanchain.v",
                "rtl/wb_mux.v",
                "blocks/serv/rtl/serv_top.v",
                "blocks/serv/rtl/serv_mem_if.v",
                "blocks/serv/rtl/serv_rf_if.v",
                "blocks/serv/rtl/serv_alu.v",
                "blocks/serv/rtl/serv_ctrl.v",
                "blocks/serv/rtl/serv_bufreg2.v",
                "blocks/serv/rtl/serv_bufreg.v",
                "blocks/serv/rtl/serv_immdec.v",
                "blocks/serv/rtl/serv_decode.v",
                "blocks/serv/rtl/serv_state.v",
                "blocks/serv/rtl/serv_csr.v",
                "blocks/serv/servant/servant_arbiter.v",
                "blocks/serv/servant/servant_mux.v",
                "blocks/serv/servant/servant_gpio.v"
            ],
            "top_module": "gregdavill_serv_top",
            "git_url": "https://github.com/gregdavill/tt02-serv"
        },
        "documentation": {
            "author": "Greg Davill",
            "discord": "Greg#9468",
            "title": "serv - Serial RISCV CPU",
            "description": "An award winning RISCV CPU!",
            "how_it_works": "This project contains a 96bit serial scanchain, and the core of the serv CPU. Signals present on the scanchain are a wishobne bus and the native registerfile interface. As there is not enough room inside the TinyTapeout project area to fit RAM/registerfiles these have to be implemented externally. In theory just a bit of custom code running on caravel will be enough to get the serv core running.",
            "how_to_test": "tbd",
            "external_hw": "tbd",
            "language": "verilog",
            "doc_link": "https://github.com/olofk/serv/tree/main",
            "clock_hz": 0,
            "picture": "tbd",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349813388252021330",
            "git_url": "https://github.com/saicharan0112/tt02-submission-template"
        },
        "documentation": {
            "author": "saicharan0112",
            "discord": "",
            "title": "4:2 Compressor",
            "description": "A Basic 4:2 compressor which contains 4 inputs and 1 carry_in bit which compresses to 2 outputs and 1 carry_out bit",
            "how_it_works": "It compressors 4 inputs to 2 inputs. This is used to compress partial products inside multipliers",
            "how_to_test": "Follow the truth table of 4:2 compressor online with 4 inputs and carry_in bit and observe the 2 outputs and carry_out bit",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "a1 is one of the 4 main input bits",
                "a2 is one of the 4 main input bits",
                "a3 is one of the 4 main input bits",
                "a4 is one of the 4 main input bits",
                "cin is the carry_in input bit",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "o1 is the one of the 3 compressed output bits",
                "o2 is the one of the 3 compressed output bits",
                "cout is the carry_out bit",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349934460979905106",
            "git_url": "https://github.com/tanishnk/Tiny-Tapeout-2-submission-Tanish-k"
        },
        "documentation": {
            "author": "Tanish Khanchandani",
            "discord": "ripper#0014",
            "title": "PS2 keyboard Interface",
            "description": "PS2 keyboard interface to enter charecters into a computer. Use the PS2 hex scan codes (https://techdocs.altium.com/display/FPGA/PS2+Keyboard+Scan+Codes) to enter hex codes and it will send the letter to your computer.",
            "how_it_works": "Most likely does not work. Takes in keyboard hex scan codes and sends data to your PC. The chip emulates a key being pressed down and released. (link to protocol - https://techdocs.altium.com/display/FPGA/PS2_W+-+Transmission+Protocols). The logic puts data into a parallel to serial interface and sends the data with some of the other protocol necessities to simulate a key being pressed and released.",
            "how_to_test": "Select clock with input 1. Set the first hex character using inputs 2-5. Set input 6 to 1. Set input 6 back to 0. Set the second hex character using inputs 2-5 and set input 7 to 1 and then back to 0. Set input 8 to 1 to send the data.",
            "external_hw": "3.3V to 5V logic level converter",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 6000,
            "picture": "",
            "inputs": [
                "clock",
                "hex Bit 1",
                "hex Bit 2",
                "hex Bit 3",
                "hex Bit 4",
                "Set 1st hex",
                "set 2nd hex",
                "Enable to send"
            ],
            "outputs": [
                "NC",
                "NC",
                "NC",
                "NC",
                "NC",
                "NC",
                "Clock",
                "Data"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "user_module_skylersaleh.v"
            ],
            "top_module": "user_module_skylersaleh",
            "git_url": "https://github.com/skylersaleh/tt02-hello"
        },
        "documentation": {
            "author": "Skyler Saleh",
            "discord": "",
            "title": "Hello Generator",
            "description": "Flashes 'H-E-L-L-O' on the 7 segment display",
            "how_it_works": " An input clock signal is fed into a configureable clock divider which generates a slower clock every 1 to 2^15 cycles (depending on configuration). The rate of the clock divider is configured using the dipswitches under the equation of output_clock_hz = input_clock_hz/(2^clock_divider_ratio[3:0])\nThis slow clock increments a 3 bit counter which is used to index a built in character generator ROM, whose outputs will be used to drive the segment a,b,c,d,e,f,g on the 7 seg display. The character rom contains bits to light up the segments as 'H-E-L-L-O- - - '\nThe outputs of the character rom are anded with (slow_clock|flash_enable) to cause the display to blank between letters when flashing is enabled.\nA debug harness(accessed by setting the debug_mode dip switch to 1) allows the character generator rom to be indexed using dip switch settings, and for the slow clock to be source from dip switches instead of the clock divider. ",
            "how_to_test": " Configure input clock rate as 2048hz on the first input.\nSet dip_switch[1] to 1 Set dip_switch[2] to 1 Set dip_switch[3] to 0 Set dip_switch[4] to 1\nThis will configure the input clock divider to generate a 1Hz slow clock from the 2048hz input clock.\nSet dip_switch[5] to 0 Set dip_switch[6] to 0 Set dip_switch[7] to 0\nThis will disable the test harness and setup normal operation.\nConnect a 7 segment display to outputs, and the device should flash 'H-E-L-L-O' followed by 3 letters worth of blank display.\n",
            "external_hw": "None",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 2048,
            "picture": "",
            "inputs": [
                "clock",
                "if debug_mode == 0: clock_divider_ratio[0] elif debug_mode == 1: character_rom_index[0]",
                "if debug_mode == 0: clock_divider_ratio[1] elif debug_mode == 1: character_rom_index[1]",
                "if debug_mode == 0: clock_divider_ratio[2] elif debug_mode == 1: character_rom_index[2]",
                "if debug_mode == 0: clock_divider_ratio[3] elif debug_mode == 1: slow_clock_output (used for flash generator)",
                "flash enable: 0 = Flash display between each output letter. 1 = Do not flash display.",
                "must be zero: 0 = Prints 'H-E-L-L-O' 1 = Implementation defined behavior",
                "debug_mode: 0 = normal operation, 1 = debug mode"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "segment decimal"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "user_module_341628725785264722.v"
            ],
            "top_module": "user_module_341628725785264722",
            "git_url": "https://github.com/BarsMonster/MicroAsicVI"
        },
        "documentation": {
            "author": "Mikhail Svarichevsky",
            "discord": "ZeptoBars#7360",
            "title": "MicroASIC VI",
            "description": "Free-running oscillators to verify simulation vs reality + TRNG",
            "how_it_works": "Combinational loops with dividers to bring output frequency to <50kHz range",
            "how_to_test": "Select oscillator (pins 4-6) and mesaure frequency on one of output pins. Observe true random numbers at pin 7.",
            "external_hw": "You might benefit from frequency counter than can do averaging across extended period of time. ",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock in (for debugging)",
                "reset",
                "shift register clk",
                "shift register data",
                "clock source id_0",
                "clock source id_1",
                "clock source id_2",
                "unused"
            ],
            "outputs": [
                "clock divided by 2^10",
                "clock divided by 2^14",
                "clock divided by 2^18",
                "clock divided by 2^22",
                "clock divided by 2^26",
                "clock divided by 2^30",
                "clock divided by 2^32",
                "Bit 11 of shift register (to ensure it's not optimized away)"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "recepsaid_euclidean_algorithm.v",
                "gcd_top.v",
                "gcd_control.v",
                "gcd_datapath.v",
                "ssd_decoder.v"
            ],
            "top_module": "recepsaid_euclidean_algorithm",
            "git_url": "https://github.com/RecepSaid/tt02-euclidean-algorithm"
        },
        "documentation": {
            "author": "Recep Said Dulger",
            "discord": "Recep Said Dulger#4241",
            "title": "Optimised Euclidean Algorithm",
            "description": "Finding gcd of 2 4-bit number",
            "how_it_works": "This circuit finds the gcd (greatest common divisor) of 2 4-bit numbers which are entered by dip switch and it uses the Euclidean algorithm. Result displays by seven segment display. The algorithm has been optimized by designing the control unit and datapath.",
            "how_to_test": "Enter 4-bit 1st number by dip switches and set num_okey switch to 1. By doing that 1st number saved in register. Set num_okey switch to 0 and enter 2nd 4-bit number. Set num_okey switch to 0 and after that gcd result will appear in seven segment display.",
            "external_hw": "None",
            "language": "Verilog",
            "doc_link": "https://github.com/RecepSaid/tt02-euclidean-algorithm",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "number[0]",
                "number[1]",
                "number[2]",
                "number[3]",
                "none",
                "rst",
                "num_okey"
            ],
            "outputs": [
                "ssd_out[0]",
                "ssd_out[1]",
                "ssd_out[2]",
                "ssd_out[3]",
                "ssd_out[4]",
                "ssd_out[5]",
                "ssd_out[6]",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349833797657690706",
            "git_url": "https://github.com/8086net/tt02-CRC16"
        },
        "documentation": {
            "author": "Chris Burton",
            "discord": "burtyb#2164",
            "title": "CRC-16 and Parity calculator",
            "description": "CRC-16/XModem and Even Parity calculator based on Ben Eater error detection videos.",
            "how_it_works": "Two banks of CRC calculators (A and B) each with inputs for the shift register data and clock, active low reset (when high toggle shiftClk to reset) and read back mode which disables the feedback XOR to allow reading data back out.",
            "how_to_test": "Connect Pico as shown in Wokwi and run test code to send a string, read back calculated CRC/parity and compare.",
            "external_hw": "Can be used with any microcontroller, or by toggling switches.",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "nRst_A",
                "shiftData_A",
                "shiftClk_A",
                "nRead_A",
                "nRst_B",
                "shiftData_B",
                "shiftClk_B",
                "nRead_B"
            ],
            "outputs": [
                "crcOutput_A",
                "parity_A",
                "none",
                "none",
                "crcOutput_B",
                "parity_B",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "mod8_counter.v",
                "cw0_pattern.v",
                "ccw0_pattern.v",
                "cw8_pattern.v",
                "ccw8_pattern.v",
                "snake_cw_pattern.v",
                "snake_ccw_pattern.v",
                "vscan_pattern.v",
                "hscan_pattern.v",
                "warn1_pattern.v",
                "warn2_pattern.v",
                "warn3_pattern.v",
                "warn4_pattern.v",
                "warn5_pattern.v",
                "warn6_pattern.v",
                "xscan_pattern.v",
                "rand_pattern.v",
                "fx_gen.v",
                "digit_gen.v",
                "mux2.v",
                "mux16.v",
                "msaghir_top_level.v"
            ],
            "top_module": "msaghir_top_level",
            "git_url": "https://github.com/mazensaghir/tt02-sevsegfx"
        },
        "documentation": {
            "author": "Mazen Saghir, ECE Department, American University of Beirut (mazen@aub.edu.lb)",
            "discord": "msaghir#7355",
            "title": "SevSegFX",
            "description": "Seven segment display effect generator",
            "how_it_works": "Generates hexadecimal digits and 16 dynamic patterns on the seven segment display.",
            "how_to_test": "Use input[7] to display digits (=0) or effects (=1). Use input[6] to blink displayed digits (=1) or not (=0). Only digits can be blinked. Use inputs [5:2] to select digit or effect pattern to display.",
            "external_hw": "",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 12500,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "sel0/d0",
                "sel1/d1",
                "sel2/d2",
                "sel3/d2",
                "blink",
                "fx"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341631644820570706",
            "git_url": "https://github.com/tzachari/tt02-lab11"
        },
        "documentation": {
            "author": "Thomas Zachariah",
            "discord": "",
            "title": "LAB11",
            "description": "Cycles through the characters of LAB11",
            "how_it_works": "Gates & flip-flops connected to the 7-segment display change the state of corresponding LED segments to form the next character, each cycle",
            "how_to_test": "Set to desired clock speed \u2014 characters are most readable at the lowest speed",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "https://github.com/tzachari/tt02-lab11",
            "clock_hz": 1,
            "picture": "tt02-lab11.gif",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "top.v"
            ],
            "top_module": "option23ser",
            "git_url": "https://github.com/bitluni/tt02-option23ser"
        },
        "documentation": {
            "author": "bitluni",
            "discord": "bitluni#0204",
            "title": "Option23 Serial",
            "description": "Character ROM and bitmap shifter for POV displays",
            "how_it_works": "clock: clocks out character columns or shifts in data. Data is 8bits LSB first. Highest bit is ignored. Data = b01xxxxxx ASCII character no x + 32. data = b00xxxxxx bitmap column. under/over is underline and overline for all bitmap columns",
            "how_to_test": "Shift in some data and set din = 1111111 to clock out characters and graphics",
            "external_hw": "Pink LEDs",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "write",
                "din",
                "under",
                "over",
                "none",
                "none"
            ],
            "outputs": [
                "led 0",
                "led 1",
                "led 2",
                "led 3",
                "led 4",
                "led 5",
                "led 6",
                "led 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "top.v"
            ],
            "top_module": "option23",
            "git_url": "https://github.com/bitluni/tt02-option23"
        },
        "documentation": {
            "author": "bitluni",
            "discord": "bitluni#0204",
            "title": "Option23",
            "description": "Character ROM and bitmap shifter for POV displays",
            "how_it_works": "clock: clocks out character columns or shifts in data. din = 1111111: show characters and bitmaps column by column. din = 1xxxxxx shift in ASCII character x. din = b10xxxxx : shift in bitmap column xxxxx",
            "how_to_test": "Shift in some data and set din = 1111111 to clock out characters and graphics",
            "external_hw": "Pink LEDs",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "din 0",
                "din 1",
                "din 2",
                "din 3",
                "din 4",
                "din 5",
                "din 6"
            ],
            "outputs": [
                "led 0",
                "led 1",
                "led 2",
                "led 3",
                "led 4",
                "led 5",
                "led 6",
                "led 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "top.v"
            ],
            "top_module": "option22",
            "git_url": "https://github.com/bitluni/tt02-option22"
        },
        "documentation": {
            "author": "bitluni",
            "discord": "bitluni#0204",
            "title": "Option22",
            "description": "Looong shift register. 22x8 bit",
            "how_it_works": "write=high: Data is shifted-in on clock positive edge. Each 8 clocks a full byte is buffered at the output. It rotatetes all 22 words. Reset only resets internal counter for the bit index.",
            "how_to_test": "Keep write high and push 22x8 bits in. Keep clock with write low to recieve the bytes a the output",
            "external_hw": "Pink LEDs",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "write",
                "data",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "led 0",
                "led 1",
                "led 2",
                "led 3",
                "led 4",
                "led 5",
                "led 6",
                "led 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341557831870186068",
            "git_url": "https://github.com/theFestest/tt02-4x4-ram"
        },
        "documentation": {
            "author": "Michael Bartholic",
            "discord": "theFestest#7917",
            "title": "4x4 RAM",
            "description": "4 word, 4 bit read/write RAM",
            "how_it_works": "Set write enable to write to the given address. Read given address on output.",
            "how_to_test": "Set a word on data lines, set address on addr lines. Cycle write enable. Try reading value on rdata.",
            "external_hw": "None.",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "data[0]",
                "data[1]",
                "data[2]",
                "data[3]",
                "addr[0]",
                "addr[1]",
                "write_enable"
            ],
            "outputs": [
                "rdata[0]",
                "rdata[1]",
                "rdata[2]",
                "rdata[3]",
                "addr[0]",
                "addr[1]",
                "clock",
                "write_enable"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341438392303616596",
            "git_url": "https://github.com/jeanthom/tinytapout-lock"
        },
        "documentation": {
            "author": "Jean THOMAS",
            "discord": "",
            "title": "Digital padlock",
            "description": "A 4-digit electronic padlock",
            "how_it_works": "Each buttons press is detected by a rising edge detector, and each button press is decoded into a binary code. That binary code is stored in a shift-register which is continuously checked against a reference value ('the padlock code').",
            "how_to_test": "Connect a clock generator to the clock input, connect all four buttons with a debounce circuit - the buttons should act as active high.",
            "external_hw": "Four push buttons, cabled as active high with hardware debounce circuitry.",
            "language": "wokwi",
            "doc_link": "README.md",
            "clock_hz": 100,
            "picture": "high-level-diagram.png",
            "inputs": [
                "clock",
                "Button A",
                "Button B",
                "Button C",
                "Button D",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "Button press detected",
                "Code valid"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349952820323025491",
            "git_url": "https://github.com/jdrosent/tt02-submission-template"
        },
        "documentation": {
            "author": "James R",
            "discord": "jamesr#0350",
            "title": "FFT Butterfly in Wokwi",
            "description": "Single FFT butterfly with 2-bit resolution",
            "how_it_works": "Calculates low-resolution FFT of two 2-bit inputs",
            "how_to_test": "Change the inputs",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "xr0.0",
                "xr0.1",
                "xj0.0",
                "xj0.1",
                "xr1.0",
                "xr1.1",
                "xj1.0",
                "xj1.1"
            ],
            "outputs": [
                "xr0.0",
                "Xr0.1",
                "Xj0.0",
                "Xj0.1",
                "Xr1.0",
                "Xr1.1",
                "Xj1.0",
                "Xj1.1"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "ALU.v",
                "Femto-top.v",
                "reg_file.v",
                "decoder.v",
                "ibuff.v"
            ],
            "top_module": "femto_top",
            "git_url": "https://github.com/majdiabdulsamad/tt02-Femto"
        },
        "documentation": {
            "author": "Majdi Abdul Samad",
            "discord": "mia42#1188",
            "title": "Femto 4-bit CPU",
            "description": "Design of a small single-cycle CPU with simple RISC/Accumulator ISA",
            "how_it_works": "Contains a register file, ALU, and 7 segment decoder. Instructions are sent in from inputs 7 downto 1 (0 reserved for clk), the register source and destination are sent to the register file (synch write/asynch read). Opcode and register read data are sent to the ALU for the operation. The output data could be stored in the ALU, the reigster file, or sent to the 7 segment decoder to power the LED output.",
            "how_to_test": "Design was tested with a ModelSim TCL script, provided here and should be compatible with other TCL accepting simulators.",
            "external_hw": "None",
            "language": "Verilog",
            "doc_link": "README.md",
            "clock_hz": 5,
            "picture": "../Femto-arch.svg",
            "inputs": [
                "clock",
                "opcode[0]",
                "opcode[1]",
                "opcode[2]",
                "reg_dest[0]",
                "reg_dest[1]",
                "reg_src[0]",
                "reg_src[1]"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "toplevel/logisimTopLevelShell.v",
                "circuit/main.v",
                "gates/NAND_GATE.v",
                "gates/OR_GATE.v",
                "gates/OR_GATE_3_INPUTS.v",
                "gates/OR_GATE_4_INPUTS.v",
                "memory/D_FLIPFLOP.v"
            ],
            "top_module": "logisim_demo",
            "git_url": "https://github.com/AvalonSemiconductors/tt02-logisim-example"
        },
        "documentation": {
            "discord": "Tholin#7559",
            "author": "Tholin",
            "title": "Logisim demo - LED blinker",
            "description": "Example of how to use Logisim Evolution generated Verilog for TinyTapeout.",
            "how_it_works": "Its a 4-bit ring-shift register with a single '1' cycling through it after reset.",
            "how_to_test": "After starting the clock, the 4 outputs will remain off or in a random state until the reset input is activated. Then it should work as described.",
            "external_hw": "A button for reset, some way to display the output (LEDs)",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 2,
            "picture": "",
            "inputs": [
                "CLK",
                "RST",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "O_0",
                "O_1",
                "O_2",
                "O_3",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "top.v"
            ],
            "top_module": "secretFile",
            "git_url": "https://github.com/bitluni/tt02-SecretFile"
        },
        "documentation": {
            "author": "bitluni",
            "discord": "bitluni#0204",
            "title": "Secret File",
            "description": "Nothing to see here",
            "how_it_works": "Leving it alone works",
            "how_to_test": "Don't test me",
            "external_hw": "Shredder",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "bit 0",
                "bit 1",
                "bit 2",
                "bit 3",
                "bit 4",
                "bit 5",
                "bit 6",
                "bit 7"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349519263900369490",
            "git_url": "https://github.com/cmu-stuco-98154/f22-tt02-qilins"
        },
        "documentation": {
            "author": "Samuel Sun",
            "discord": "",
            "title": "Hex to Seven Semgent Converter",
            "description": "Converts from a binary input to hex seven-segment display",
            "how_it_works": "Input binary, get seven-segment hex out",
            "how_to_test": "Input binary, get seven-segment hex out",
            "external_hw": "seven-segment",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "poisonninja_top.v",
                "pwm_generator.v"
            ],
            "top_module": "poisonninja_top",
            "git_url": "https://github.com/cmu-stuco-98154/f22-tt02-jxlu"
        },
        "documentation": {
            "author": "Jason Lu",
            "discord": "",
            "title": "PWM Generator",
            "description": "Generates 100 Hz PWM signal",
            "how_it_works": "The duty cycle inputs run from 0 - 50 and specify a duty cycle of input * 2",
            "how_to_test": "Link up switches to the duty cycle inputs and toggle them to set the duty cycle. Wire an LED to the PWM output to see the output",
            "external_hw": "",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": 5000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "duty cycle 0",
                "duty cycle 1",
                "duty cycle 2",
                "duty cycle 3",
                "duty cycle 4",
                "duty cycle 5"
            ],
            "outputs": [
                "pwm output",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "349803790984020562",
            "git_url": "https://github.com/cmu-stuco-98154/f22-tt02-mgee3"
        },
        "documentation": {
            "author": "MG",
            "discord": "",
            "title": "3-bit adder",
            "description": "Add two 3-bit numbers",
            "how_it_works": "Adds A0 A1 A2 and B0 B1 B2 implemented using one half-adder and two full-adders. LEDs light up correspondingly.",
            "how_to_test": "Result: binary added score at output LED",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "A0, lowest order bit of first number",
                "A1, second order bit of first number",
                "A2, highest order bit of first number",
                "B0, lowest order bit of second number",
                "B1, second order bit of second number",
                "B2, highest order bit of second number",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "math.sv"
            ],
            "top_module": "sophialiCMU_math",
            "git_url": "https://github.com/cmu-stuco-98154/f22-tt02-sophiali"
        },
        "documentation": {
            "author": "Sophia Li",
            "discord": "Sophia Li#3497",
            "title": "Continious Math",
            "description": "output is a total you can ADD, SUBTRACT, XOR, or LEFT_SHIFT with the input  ",
            "how_it_works": "uses a register and some combinational logic. There is a simple state machine so you must release the button for enable_arithmetic before enabeling it again. Basically, the same operation won't happen every clock cycle 100k times a second.",
            "how_to_test": "Switch 6. after reset, the output should be zero. Hitting enable (Switch 5) will compute the current arithOp (+ = 2'b00, - = 2'b01, ^ = 2'b10, << = 2'b11",
            "external_hw": "",
            "language": "SystemVerilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "enable",
                "in_val[2]",
                "in_val[1]",
                "in_val[0]",
                "arithOp[1]",
                "arithOp[0]"
            ],
            "outputs": [
                "LED[7]",
                "LED[6]",
                "LED[5]",
                "LED[4]",
                "LED[3]",
                "LED[2]",
                "LED[1]",
                "LED[0]"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "top.sv",
                "async-fifo.sv"
            ],
            "top_module": "jonpaolo02_async_fifo",
            "git_url": "https://github.com/cmu-stuco-98154/f22-tt02-jrecta"
        },
        "documentation": {
            "author": "Jon Recta",
            "discord": "jonpaolo02#0802",
            "title": "Async FIFO",
            "description": "A very small asynchonous FIFO",
            "how_it_works": "After reset, run write_clock and assert write_enable with some data on wdata, then while run_clock is running, assert read_enable. If write_enable is asserted while full is high, the data will be rejected. If read_enable is asserted while empty is high, read_data is invalid.",
            "how_to_test": "After resetting, test above behavior with different ratios of write_clock and read_cloc.",
            "external_hw": "None",
            "language": "SystemVerilog",
            "doc_link": "https://github.com/jonpaolo02/tt02-async-fifo/blob/main/README.md",
            "clock_hz": 5000,
            "picture": "",
            "inputs": [
                "write_clock",
                "read_clock",
                "reset",
                "write_enable",
                "read_enable",
                "wdata[0]",
                "wdata[1]",
                "wdata[2]"
            ],
            "outputs": [
                "none",
                "none",
                "none",
                "fifo_full",
                "fifo_empty",
                "rdata[0]",
                "rdata[1]",
                "rdata[2]"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "beepboop.sv"
            ],
            "top_module": "asinghani_beepboop",
            "git_url": "https://github.com/asinghani/tt02-beepboop"
        },
        "documentation": {
            "author": "Anish Singhani",
            "discord": "",
            "title": "Beep Boop Traffic Light Controller",
            "description": "Sequencer for a traffic light with a walk button, with timings tuned to match the iconic 'beep boop' streetlight formerly installed in front of Carnegie Mellon University",
            "how_it_works": "Press the walk button and the traffic light will turn red, then the walk signal and 'beep boop' will begin",
            "how_to_test": "See inputs and outputs",
            "external_hw": "LEDs, noisemaker, button",
            "language": "SystemVerilog",
            "doc_link": "",
            "clock_hz": 100,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "walk button",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "red",
                "yellow",
                "green",
                "walk",
                "no walk",
                "noisemaker",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "cpu.sv"
            ],
            "top_module": "noahgaertner_cpu",
            "git_url": "https://github.com/noahgaertner/tt02-verilog-demo"
        },
        "documentation": {
            "author": "Noah Gaertner",
            "discord": "Neptun0-#1146",
            "title": "Basic 4 bit cpu ",
            "description": "4-bit CPU that does add, subtract, multiply, left and right shifts, conditional jump based on external signal, logical and bitwise AND and OR, equality and inequality checking, bitwise inversion, and logical NOT",
            "how_it_works": "Implements a highly reduced ISA that fits on the limited allowed space, and uses a 4-bit bus to get the program and data values in and out of the chip, in addition to a two bit bus to tell it what to do at any given time, as well as a clock and reset signal",
            "how_to_test": "Write a program for the ISA and try to run it! Remember you need to synchronously RESET and then SETRUNPT to the proper value before you try to do anything!",
            "external_hw": "test pattern generator, output reader (will probably work with just an arduino for both)",
            "language": "SystemVerilog",
            "doc_link": "https://github.com/noahgaertner/tt02-verilog-demo/blob/main/README.md",
            "clock_hz": "50K (or lower, whatever)",
            "picture": "docs/pic.png",
            "inputs": [
                "clock",
                "reset",
                "instruction",
                "instruction",
                "data",
                "data",
                "data",
                "data"
            ],
            "outputs": [
                "program counter",
                "program counter",
                "program counter",
                "program counter",
                "output data",
                "output data",
                "output data",
                "output data"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341613097060926036",
            "git_url": "https://github.com/prabaldutta/tt02-adi-demo"
        },
        "documentation": {
            "author": "Prabal Dutta",
            "discord": "",
            "title": "Adi counter",
            "description": "Test FSM",
            "how_it_works": "Clocks FSM on button push",
            "how_to_test": "Hook up to 7-deg display, push button, and see A-d-i cycle on LEDs",
            "external_hw": "Just PB and 7-seg",
            "language": "wokwi",
            "doc_link": "none",
            "clock_hz": 1,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341353928049295956",
            "git_url": "https://github.com/TinyTapeout/tt02-tinytapeout-clock-divider-asic"
        },
        "documentation": {
            "author": "Sad Electronics",
            "discord": "A13 #8574",
            "title": "Clock divider ASIC",
            "description": "Uses a series of flip flops to divide the clock",
            "how_it_works": "todo",
            "how_to_test": "todo",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "gray_ctr6.v"
            ],
            "top_module": "tucanae47_gray_ctr6",
            "git_url": "https://github.com/tucanae47/tt02-gray-counter"
        },
        "documentation": {
            "author": "Camilo Soto",
            "discord": "tucanae47#6105",
            "title": "Amaranth 6 Bits Gray counter",
            "description": "Amaranth Gray 6 Bits gray counter",
            "how_it_works": "The reflected binary code (RBC), also known as reflected binary (RB) or Gray code after Frank Gray, \nis an ordering of the binary numeral system such that two successive values differ in only one bit (binary digit).\nFor example, the representation of the decimal value \"1\" in binary would normally be \"001\" and \"2\" would be \"010\". \nIn Gray code, these values are represented as \"001\" and \"011\". That way, incrementing a value from 1 to 2 requires\nonly one bit to change, instead of two (Wikipedia https://en.wikipedia.org/wiki/Gray_code)\n",
            "how_to_test": "Apply clk to the in[0], rst on in[1]",
            "external_hw": "None",
            "language": "Amaranth",
            "doc_link": "https://github.com/tucanae47/tt02-gray-counter",
            "clock_hz": 3000,
            "picture": "None",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "count[0]",
                "count[1]",
                "count[2]",
                "count[3]",
                "count[4]",
                "count[5]",
                "count[6]",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "340805072482992722",
            "git_url": "https://github.com/TinyTapeout/tt02-test-7seg"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn",
            "title": "7 segment seconds",
            "description": "counts from 0 to 9, incrementing once per second",
            "how_it_works": "counter + combinational logic",
            "how_to_test": "set the clock divider to 1 hz. toggle reset and watch the 7 segment display",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 1,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "counter.v",
                "decoder.v"
            ],
            "top_module": "seven_segment_seconds",
            "git_url": "https://github.com/TinyTapeout/tt02-verilog-demo"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "7 segment seconds",
            "description": "count up to 10, one second at a time",
            "how_it_works": "uses a register and some combinational logic",
            "how_to_test": "after reset, the counter should increase by one every second",
            "external_hw": "",
            "language": "verilog",
            "doc_link": "",
            "clock_hz": 1000,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341678527574180436",
            "git_url": "https://github.com/mattvenn/tt02-laura"
        },
        "documentation": {
            "author": "Laura",
            "discord": "",
            "title": "Laura's L",
            "description": "Makes an L on the 7 segment when you press buttons 1 & 2",
            "how_it_works": "just an and gate",
            "how_to_test": "press buttons 1 & 2 to see the L",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "none",
                "button 1",
                "button 2",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "339688086163161683",
            "git_url": "https://github.com/mattvenn/tt02-m-segments"
        },
        "documentation": {
            "author": "Matt Venn",
            "title": "M segments",
            "discord": "",
            "description": "Setting the correct input will show a 3 on the display",
            "how_it_works": "AND gates connect to the 7 segment display",
            "how_to_test": "Turning on the first 4 inputs will show a 3 on the display",
            "external_hw": "None",
            "doc_link": "",
            "clock_hz": 0,
            "language": "wokwi",
            "picture": "msegments.png",
            "inputs": [
                "input 1",
                "input 2",
                "input 3",
                "input 4",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "dot"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347497504164545108",
            "git_url": "https://github.com/jdrosent/tt02-7segstringdisplay"
        },
        "documentation": {
            "author": "Tiny Tapeout 02 (J. Rosenthal)",
            "discord": "jamesr#0350",
            "title": "7-Seg 'Tiny Tapeout' Display",
            "description": "This circuit will output a string of characters (\u2019tiny tapeout\u2019) to the 7-segment display.",
            "how_it_works": "The logic to light the characters appears in the bottom half of the simulation window. The top half of the simulation window implements a modulo-11 counter. In other words, the counter increments up to 11 then resets. This counter is used to determine which character we should output to the 7-segment display. The truth table for the design can be found in the Design Spreadsheet: https://docs.google.com/spreadsheets/d/1-h9pBYtuxv6su2EC8qBc6nX_JqHXks6Gx5nmHFQh_30/edit",
            "how_to_test": "Simply turn on and watch the characters on the 7-segment display. If needed, flip Input[1] (zero-indexed) ON to reset the state machine counter.",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "https://wokwi.com/projects/347497504164545108",
            "clock_hz": 1,
            "picture": "",
            "inputs": [
                "clock",
                "Reset Counter",
                "N/A",
                "Clock Disable (Test Mode)",
                "Test Logic A",
                "Test Logic B",
                "Test Logic C",
                "Test Logic D"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "N/A"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347140425276981843",
            "git_url": "https://github.com/jdrosent/tt02-UARTcharacter"
        },
        "documentation": {
            "author": "Tiny Tapeout 02 (J. Rosenthal)",
            "discord": "jamesr#0350",
            "title": "Customizable UART Character",
            "description": "This design implements a single character UART transmitter using registers made from D-flip flops and multiplexers.",
            "how_it_works": "This circuit implements a shift register with 17 bits: four idle bits, one start bit, eight data bits, one stop bit, and three more idle bits. The circuit supports transmitting a user-selected ASCII character from 0x40 (@) to 0x5F (_), including capital letters from the Latin alphabet.",
            "how_to_test": "Connect an Arduino serial RX pin to the eight output pin (Output[7]). In the Arduino code, set the serial baud rate Serial.begin(<baud rate>); in the *.ino file to 300. Set the PCB clock frequency to 300 Hz as well. Set SW7 to OFF (\u201cLoad\u201d). Set SW2 to ON and SW3-6 to OFF. Set SW7 to ON (\u201cTX\u201d). Set SW8 to ON (\u201cOutput Enable\u201d). Connect the Arduino via USB to your computer and run the serial monitor. If there\u2019s no output from the Arduino serial monitor, try toggling SW7 OFF and ON again. You should see the character 'A' appearing repeatedly in the serial monitor.",
            "external_hw": "Arduino, computer with serial monitor connected to the Arduino",
            "language": "wokwi",
            "doc_link": "https://wokwi.com/projects/347140425276981843",
            "clock_hz": 300,
            "picture": "",
            "inputs": [
                "clock",
                "Bit 0",
                "Bit 1",
                "Bit 2",
                "Bit 3",
                "Bit 4",
                "Load/TX",
                "Output Enable"
            ],
            "outputs": [
                "segment a (Load/TX)",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f (Output Enable)",
                "segment g",
                "UART Serial Out"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347144898258928211",
            "git_url": "https://github.com/jdrosent/tt02-UARTstring"
        },
        "documentation": {
            "author": "Tiny Tapeout 02 (J. Rosenthal)",
            "discord": "jamesr#0350",
            "title": "Customizable UART String",
            "description": "This design Supports sending multiple ASCII characters over UART.",
            "how_it_works": "This circuit implements five shift registers with 21 bits: seven idle bits, one start bit, eight data bits, one stop bit, and four more idle bits. The circuit supports transmitting a string of ASCII characters ",
            "how_to_test": "Connect an Arduino serial RX pin to the eight output pin (Output[7]). In the Arduino code, set the serial baud rate Serial.begin(<baud rate>); in the *.ino file to 300. Set the PCB clock frequency to 300 Hz as well. Set the slide switch to the clock. Set SW7 to OFF ('Load'). Set SW8 to ON ('Output Enable'). Set SW7 to ON ('TX').",
            "external_hw": "Arduino, computer with serial monitor connected to the Arduino",
            "language": "wokwi",
            "doc_link": "https://wokwi.com/projects/347144898258928211",
            "clock_hz": 300,
            "picture": "",
            "inputs": [
                "clock",
                "N/A",
                "N/A",
                "N/A",
                "N/A",
                "N/A",
                "Load/TX",
                "Output Enable"
            ],
            "outputs": [
                "segment a (Output Enable)",
                "segment b (Load/TX)",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "UART Serial Out"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "347417602591556180",
            "git_url": "https://github.com/jdrosent/tt02-padlock"
        },
        "documentation": {
            "author": "Tiny Tapeout 02 (J. Rosenthal)",
            "discord": "jamesr#0350",
            "title": "Customizable Padlock",
            "description": "This design implements a customizable padlock. Set a code for your digital safe!",
            "how_it_works": "Switch 2 is used to reset the safe. Switch 8 is used to set your code (on = set, off = locked). Switches 3 to 5 are used to set the code. The push button is used to enter your code.",
            "how_to_test": "Set your desired code using Switches 3 to 5. Once you\u2019ve done so, toggle Switch 8 to on then back off\u2013the safe is now set! Turn on Switch 2, and press the push button. The seven segment display should show \u201cL\u201d (for locked). Next turn off Switch 2 to begin entering codes. If you enter a correct code, thw seven segment display should show \u201cU\u201d (for unlocked).",
            "external_hw": "None",
            "language": "wokwi",
            "doc_link": "https://wokwi.com/projects/347417602591556180",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "N/A",
                "Reset",
                "Code 0",
                "Code 1",
                "Code 2",
                "N/A",
                "N/A",
                "Set Code"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "razhas_top_level.v",
                "pwm_gen.v"
            ],
            "top_module": "razhas_top_level",
            "git_url": "https://github.com/H-Bydn/TinyTapeout2-PWMgenerator"
        },
        "documentation": {
            "author": "Hassan Baydoun <hhb16@mail.aub.edu>, Razan Thebian <rat17@mail.aub.edu>: Electrical and Computer Engineering Department, American University of Beirut ",
            "discord": "bydn#1103",
            "title": "PWM Generator",
            "description": "It is a PWM Generator with selectable duty cycle 0-10-20-..-100% with clock divider built in",
            "how_it_works": "The design uses an external clock and 4 bits to select the duty cycle. It outputs a PWM signal with 1/10 the frequency of the clock supplied and a duty cycle depending on the 4 selected bits.",
            "how_to_test": "Use clock on input 0, reset on input 1, Turn bits of duty cycle select (input 2:5) to choose duty cycle (0000 -> 0%, 0001 -> 10%, 0010 -> 20%,.., 1010 ->100% ) and choose freq0 and freq1 as clock dividers (1x, 1/2x, 1/4x, 1/8x)",
            "external_hw": "You can control the intensity of an external LED using the PWM Output",
            "language": "Verilog",
            "doc_link": "",
            "clock_hz": "12500Hz",
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "duty0",
                "duty1",
                "duty2",
                "duty3",
                "freq0",
                "freq1"
            ],
            "outputs": [
                "PWM_Out",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "0",
            "source_files": [
                "c_tt2_mrcs_test.v"
            ],
            "top_module": "c_tt2_mrcs_test",
            "git_url": "https://github.com/aiunderstand/tt02-mrcs-verilog-test"
        },
        "documentation": {
            "author": "Steven Bos",
            "discord": "steveb#6973",
            "title": "MRCS Verilog test",
            "description": "Testing various auto-generated verilog for various sync and async logic gates",
            "how_it_works": "This Project contains various latches and one edge detector. \n\nA larger description will follow.\n",
            "how_to_test": "A complete description to test will follow.\n\nThere are 5 components to test.\n",
            "external_hw": "none",
            "language": "MRCS",
            "doc_link": "https://github.com/aiunderstand/tt02-mrcs-verilog-test",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    },
    {
        "project": {
            "wokwi_id": "341535056611770964",
            "git_url": "https://github.com/TinyTapeout/tt02-test-invert"
        },
        "documentation": {
            "author": "Matt Venn",
            "discord": "mattvenn#1907",
            "title": "Test Inverter Project",
            "description": "inverts every line",
            "how_it_works": "uses 8 inverters to invert every line",
            "how_to_test": "setting the input switch to on should turn the corresponding led off",
            "external_hw": "",
            "language": "wokwi",
            "doc_link": "",
            "clock_hz": 0,
            "picture": "",
            "inputs": [
                "clock",
                "reset",
                "none",
                "none",
                "none",
                "none",
                "none",
                "none"
            ],
            "outputs": [
                "segment a",
                "segment b",
                "segment c",
                "segment d",
                "segment e",
                "segment f",
                "segment g",
                "none"
            ]
        }
    }
]